1
00:00:04,710 --> 00:00:10,020
嗯嗯嗯嗯嗯

2
00:00:10,025 --> 00:00:15,030
嗯嗯嗯嗯嗯

3
00:00:15,120 --> 00:00:20,130
啊大家好啊，今天我们讲的那讲的内容是重复的，复制状态机

4
00:00:20,730 --> 00:00:25,650
我是去蓬莱自平台普适泰kv寂寞的研发工程师

5
00:00:27,240 --> 00:00:30,570
啊，首先我们看一下关键知识点

6
00:00:30,690 --> 00:00:33,630
今天我们大概介绍四个内容

7
00:00:33,635 --> 00:00:38,670
啊，前两个知识点的话是懦夫的，基本算法里面的内容

8
00:00:38,730 --> 00:00:40,860
包括了拉夫德的选举机制

9
00:00:40,950 --> 00:00:45,390
还有院服的数据复制用数据容易复制的过程

10
00:00:45,720 --> 00:00:50,010
然后第三部分呢？是我们太kt里面是怎样用？

11
00:00:50,160 --> 00:00:51,300
袜子疼

12
00:00:51,570 --> 00:00:53,850
就成一个没有TOR s的狗肉铺的

13
00:00:54,000 --> 00:00:57,300
然后最后一节就是介绍一下他KC当中

14
00:00:57,305 --> 00:00:59,970
呃，没有ter ri相关的一些监控

15
00:01:00,090 --> 00:01:04,410
呃，以便大家进行一些性能调优，或者说问题分析

16
00:01:06,360 --> 00:01:09,060
好的，我们先来看一下第一部分

17
00:01:09,090 --> 00:01:11,670
啊，差不多的背景以及基础概念

18
00:01:12,000 --> 00:01:16,890
也就是说，为什么啊？让他这个算法会被提出来

19
00:01:17,310 --> 00:01:19,290
然后它解决的是什么问题？

20
00:01:19,590 --> 00:01:24,900
然后第二部分我们就看一下亚夫特他具体的一些相关的概念以及它是

21
00:01:25,500 --> 00:01:26,880
啊，如何抽象？

22
00:01:26,910 --> 00:01:32,220
我们在实际生实际生产过程中与遇到的各种问题的

23
00:01:34,110 --> 00:01:38,160
啊，相关背景的话，主要就是在分布式系统中

24
00:01:38,220 --> 00:01:43,020
我们要实现高可用，我们就需要对数据进行容易复制

25
00:01:43,230 --> 00:01:45,990
就是从一个副本，然后给他

26
00:01:45,995 --> 00:01:49,050
搬到另外一个副本，然后通过多个副本

27
00:01:49,170 --> 00:01:50,190
来保证

28
00:01:50,370 --> 00:01:55,680
如果有机器挂掉或者说嗯有发生网络隔离

29
00:01:56,280 --> 00:02:01,590
啊，当某一些节点不可用的时候，我们仍然可以从剩下的节点访问，这部分数据

30
00:02:02,550 --> 00:02:06,720
典型的例子，比如说卖丝袜的双鞋，也就是说我们

31
00:02:06,810 --> 00:02:12,120
啊，在一些写业务，我们不仅要写一个他写一个卖刺客，我们还要写两个卖射手

32
00:02:12,570 --> 00:02:15,480
令另外一个例子是卖丝袜克的比价格复制

33
00:02:15,570 --> 00:02:19,080
啊，这些都是我们在运维场景下常见的一些

34
00:02:19,170 --> 00:02:20,040
啊？

35
00:02:20,045 --> 00:02:20,940
解决方案

36
00:02:21,960 --> 00:02:26,250
然后再在进行分布式容于复制的过程中

37
00:02:26,255 --> 00:02:30,990
啊，还出现了另外一个新的课题，那就是如何保证数据的一致性

38
00:02:31,170 --> 00:02:33,300
一一致性的意思是什么呢？

39
00:02:33,360 --> 00:02:38,670
啊，就比如说啊，写入的东西，它不能丢失，也就是说

40
00:02:40,410 --> 00:02:41,970
我写入

41
00:02:42,150 --> 00:02:47,460
当我像一个分布式系统写入一个东西的时候，我什么时候告诉客户端我已经写了

42
00:02:47,465 --> 00:02:48,540
也成功了呢

43
00:02:48,720 --> 00:02:54,030
啊，如果我等部分机器写完，就告诉客户端成功，可不可以或者？

44
00:02:54,035 --> 00:02:55,920
说我必须等全部的

45
00:02:55,925 --> 00:02:58,980
机器写入成功，我在我在才能告诉

46
00:02:59,010 --> 00:03:01,080
到处客户端我已经写成功了

47
00:03:01,290 --> 00:03:04,440
等等，也就是说我们必须有一种机制来保证

48
00:03:04,470 --> 00:03:06,990
啊，我跟客户端确认过的协助

49
00:03:06,995 --> 00:03:08,880
啊，我一定是不能丢失的

50
00:03:10,050 --> 00:03:13,740
然后另外一个一致性的要求就是写入之后的东西

51
00:03:13,770 --> 00:03:15,060
我一定能读到

52
00:03:15,300 --> 00:03:16,080
啊？

53
00:03:16,085 --> 00:03:21,390
也就是说，嗯，客户端比如说，它在分布式系统里面写了一个东西

54
00:03:21,450 --> 00:03:24,600
然后他又马上就读这个时候如果他

55
00:03:24,605 --> 00:03:29,790
读不到的话，那么这个导致的结果就可能让客户端的程序很费解

56
00:03:30,090 --> 00:03:33,210
所以说这个也是我们常见的一个一致性的保证

57
00:03:33,540 --> 00:03:36,090
啊，那么写入之后一定能读到？

58
00:03:36,095 --> 00:03:39,540
他不同的呃分布式系统，它实现的

59
00:03:40,740 --> 00:03:44,730
方案不同，就导致他的结果也不同，比如说做批判

60
00:03:44,735 --> 00:03:46,950
它只实现了绘画的一致性

61
00:03:46,980 --> 00:03:51,150
也就是说，客户端的写入过来，他只有在当前的绘画

62
00:03:51,180 --> 00:03:56,490
里面再来读他是读得到的，如果他另起一个客户端再来访问这个分布式

63
00:03:56,495 --> 00:04:01,800
是系统，他来读她是不一定能够做到的，所以说他就为他这种特性侵

64
00:04:01,805 --> 00:04:03,780
的一个名字叫绘画一巨星

65
00:04:04,740 --> 00:04:10,050
但是实际上我们需要的更多的可能是线性一致性，这样一种更高的一致性

66
00:04:10,470 --> 00:04:13,230
也就是说，我在一个客户端里面写入

67
00:04:13,350 --> 00:04:16,320
之后我不管重启一个客户端还是？

68
00:04:16,440 --> 00:04:21,390
啊，就在这当前这个会话内我之前的写入一定就是能读到的

69
00:04:21,840 --> 00:04:27,150
其实我们做数据库啊，更多的其实是需要后面这一种啊，更高的可用性

70
00:04:27,480 --> 00:04:28,860
更高的一致性

71
00:04:29,580 --> 00:04:32,790
啊，典型的时间算法就是派克的时候，然后

72
00:04:33,240 --> 00:04:36,540
然后最后一点就是一个酚a cap理论

73
00:04:36,570 --> 00:04:38,670
就是说我们看到上面

74
00:04:38,675 --> 00:04:41,490
我们在进行数据容于和

75
00:04:41,640 --> 00:04:42,540
啊？

76
00:04:42,570 --> 00:04:47,880
一致性保证的同时，不同的软件有不同的解决方案，然后也导致了不同

77
00:04:47,885 --> 00:04:48,840
那结果

78
00:04:48,845 --> 00:04:52,110
然后这些结果就描述起来很麻烦，她其实是

79
00:04:52,140 --> 00:04:54,390
并没有在一个统一的框架内的

80
00:04:54,395 --> 00:04:57,690
所以说，后来我们就提出了一个cap理论

81
00:04:57,780 --> 00:05:03,090
啊，用来就是统一的描述各种分布式系统，他们对于一致性

82
00:05:03,095 --> 00:05:04,710
点或者可用性的保障

83
00:05:04,830 --> 00:05:07,200
C cap理论是什么意思呢？

84
00:05:08,010 --> 00:05:13,320
就是啊，首先他承认网络分区或者节点故障这些现象

85
00:05:13,680 --> 00:05:15,030
它一定是存在的

86
00:05:15,420 --> 00:05:20,730
如果如如果有一个系统可以保证不存在这种现象的话，那其实我们也就不需要分别

87
00:05:20,735 --> 00:05:26,040
不是系统的对不对？我们直接在一个单位上搞就可以了，因为他反正不会挂，也不会跟

88
00:05:26,045 --> 00:05:27,180
那些失联

89
00:05:27,780 --> 00:05:31,380
然后cap理论在这一点的基础上

90
00:05:31,500 --> 00:05:34,320
啊他约定了一些

91
00:05:34,440 --> 00:05:36,660
可用性和一致性的权衡

92
00:05:36,750 --> 00:05:37,500
就是

93
00:05:37,530 --> 00:05:42,840
CP理论，它只是证明了，就是在网络分区存在的情况下

94
00:05:43,470 --> 00:05:44,400
啊？

95
00:05:44,405 --> 00:05:46,230
如果你要保证可用性

96
00:05:46,500 --> 00:05:47,340
那么

97
00:05:48,480 --> 00:05:53,460
在发生网络隔离或者接点损坏的时候，他的一致性可能就无法保证

98
00:05:53,520 --> 00:05:55,470
但如果你要求一致性

99
00:05:55,680 --> 00:06:00,990
那么它的可用性又无法得到充分的保障，所以说一个成熟

100
00:06:00,995 --> 00:06:03,180
分布式系统或者软件

101
00:06:03,750 --> 00:06:09,060
她就必须在这两者之间进行一个权衡啊，典型的我们需要

102
00:06:09,090 --> 00:06:11,700
我们典型的有两个两个解决方案吧！

103
00:06:11,730 --> 00:06:14,970
一个是全部接收失败之后，他才不可用

104
00:06:14,975 --> 00:06:17,910
一个典型的屙分布式，一种就是卡夫卡

105
00:06:18,090 --> 00:06:22,170
然后另外一个就是过半系统时过半节点失败，他就不可以？

106
00:06:22,175 --> 00:06:26,490
这个典型的就是呃一家cdr PS，还有sky

107
00:06:29,700 --> 00:06:34,290
然后我们看tack v为什么选择了f负的或者说

108
00:06:34,380 --> 00:06:38,550
啊，让我的他解决的是他是如何解决我们上述问题的

109
00:06:38,670 --> 00:06:42,210
啊，首先说服的他提供的是线性一致性的保证

110
00:06:42,270 --> 00:06:44,460
然后就像我们刚才已经说过了

111
00:06:44,465 --> 00:06:45,780
啊，这个对于

112
00:06:45,810 --> 00:06:50,760
啊，数据库等，这样这样一些一一致性要求比较高的领域

113
00:06:50,790 --> 00:06:52,170
是比较合适的

114
00:06:53,370 --> 00:06:57,300
那么，它保证的是，过半节点失败就不可用？

115
00:06:57,330 --> 00:06:59,940
而不是全部节点失败就不可用

116
00:07:01,260 --> 00:07:03,570
这个看起来就是

117
00:07:03,600 --> 00:07:08,040
呃，他的呃，部署成本是要高于另外一个算法的

118
00:07:08,070 --> 00:07:09,570
比如说卡不卡的算法？

119
00:07:09,575 --> 00:07:14,880
查询卡是全部节点失败都不可用，而抓住的这里他是过半节点失败

120
00:07:14,910 --> 00:07:16,020
他就不可用了

121
00:07:16,140 --> 00:07:18,900
那么我们在生产中一般要保证

122
00:07:18,905 --> 00:07:22,110
两节点失败之后，系统仍然是可用的

123
00:07:22,140 --> 00:07:25,890
那么卡夫卡他就只需要三副本LOL的对

124
00:07:25,950 --> 00:07:29,670
为了应对这个场景，他就需要五副本，这样看起来

125
00:07:29,700 --> 00:07:34,890
啊，老夫的算法的存数据的时候，她是需要复制用于更多的分数

126
00:07:34,920 --> 00:07:39,390
啊，他是有引入了更多的消耗消耗的

127
00:07:39,540 --> 00:07:44,850
但是引入这些消耗它的另一方面的好处就是它的延迟是比较稳定的，他更

128
00:07:44,855 --> 00:07:46,890
应该适合事务处理，而不是像

129
00:07:46,920 --> 00:07:48,630
还不太一样，更合适

130
00:07:48,750 --> 00:07:50,100
进行一些被处理

131
00:07:50,370 --> 00:07:52,050
为什么它的延迟稳定呢？

132
00:07:52,290 --> 00:07:53,460
因为

133
00:07:54,300 --> 00:07:56,940
全部是节点失败才不可用

134
00:07:56,970 --> 00:08:01,260
它的对应的另一方面就是你向客户端确认一个写入

135
00:08:01,265 --> 00:08:05,460
必须等所有节点全部写成功之后才能跟

136
00:08:05,520 --> 00:08:07,890
用户确认，那么这样子的话

137
00:08:07,950 --> 00:08:10,800
你这个分布式系统的延迟

138
00:08:10,830 --> 00:08:15,270
其实是取决于你这个系统内最快最慢的那一台机器

139
00:08:15,570 --> 00:08:20,880
而相反，在软件的里面，我只需要过半的节点确认，我就可以跟客户端确认

140
00:08:20,885 --> 00:08:21,960
他在写入了

141
00:08:21,990 --> 00:08:22,650
他们

142
00:08:22,655 --> 00:08:27,960
在重复的系统里面，你的延迟其实是取决于你最快的那三台机器

143
00:08:28,800 --> 00:08:34,110
的速度所以说啊，让他的算法，它的延迟其实相对于呃另外

144
00:08:34,115 --> 00:08:35,820
带一些算法，它是更稳定的

145
00:08:36,510 --> 00:08:41,820
还有一个优势就是实现的实现简单，然后工程实践非常成熟

146
00:08:42,180 --> 00:08:45,030
典型的就是CT CC和CK c里面

147
00:08:45,060 --> 00:08:46,980
都对师傅的进行一些

148
00:08:47,010 --> 00:08:49,050
很长很成功的实现

149
00:08:50,850 --> 00:08:52,230
最后一点

150
00:08:52,235 --> 00:08:55,770
啊，最后一个重复的的优点就是它的细节非常完备

151
00:08:56,070 --> 00:08:59,550
相比于另外一个比较复杂的算法，拍的时候是

152
00:08:59,580 --> 00:09:04,890
啊袜子的可以说是嗯，做到了在简易方面做到了极致

153
00:09:05,370 --> 00:09:10,680
对于选举算法，还有成员变更算法，这些在派出所里面只是一笔带过的东西

154
00:09:11,070 --> 00:09:16,380
丈夫她的算法里面都给出了详详细的描述，方便我们进行工程上的实现

155
00:09:18,990 --> 00:09:24,300
然后第一节第一部分，最后一个一点内容是要不得的，复制状态机，以及以及

156
00:09:24,840 --> 00:09:26,790
啊，他的一些概念嗯

157
00:09:27,300 --> 00:09:32,610
首先袜子的将用户的写入抽象为对于一个数组

158
00:09:32,615 --> 00:09:33,570
的追加

159
00:09:33,810 --> 00:09:37,140
啊比那么这个数组，它就有一个顺序性

160
00:09:37,380 --> 00:09:40,500
比如说ABC他是不等于bac的

161
00:09:40,680 --> 00:09:45,990
也就是说，你这个分布式系统，你必须要容忍网络上的一些丢包等等场景

162
00:09:46,110 --> 00:09:47,580
丢包乱序的场景

163
00:09:48,000 --> 00:09:50,790
所以说拉夫特里面他必须保证

164
00:09:51,330 --> 00:09:52,680
啊？

165
00:09:52,920 --> 00:09:58,230
一份数据从A级点复制到b节点，它不仅仅是每一个包里面的内容是一样的

166
00:09:58,770 --> 00:10:03,930
而且她包被持久化到这个数组之后，他的位置他的顺序也是一样的

167
00:10:04,530 --> 00:10:06,180
然后第二点

168
00:10:06,300 --> 00:10:09,270
啊绕口的为每一个呃

169
00:10:09,420 --> 00:10:12,480
为数组中的每一个元素都关联了一个数码

170
00:10:12,750 --> 00:10:14,730
啊，这个特码是什么意思呢？

171
00:10:14,820 --> 00:10:17,880
啊其实是啊，为了处理当

172
00:10:17,885 --> 00:10:19,860
写入有冲突的时候

173
00:10:19,865 --> 00:10:21,240
啊应该

174
00:10:21,780 --> 00:10:26,820
怎样选择正确的嗯？数据包或者说NG

175
00:10:27,900 --> 00:10:33,210
举个例子，假如说嗯一个分布式系统里面有一个节点正在

176
00:10:33,215 --> 00:10:36,420
收取其他节点给他广播的数据包

177
00:10:36,450 --> 00:10:41,760
那么假如说在这个数组的同一个位置，他收到了两个人的协议

178
00:10:41,765 --> 00:10:42,420
结束

179
00:10:42,425 --> 00:10:47,730
那么这两个人的写入，应该选择哪一个人的呢？这个其实就需要有一个比较

180
00:10:47,880 --> 00:10:51,960
那么我们就在这一个数组中每一个元素上关联一个项目

181
00:10:52,110 --> 00:10:56,820
那么他们就越大我们就越有可能保留一下那一个元素

182
00:10:58,620 --> 00:10:59,490
然后

183
00:10:59,495 --> 00:11:04,800
负责复制状态机在约定了上述内容之后，她他对一致性的保证

184
00:11:04,805 --> 00:11:09,150
就可以抽象为在多个副本之间对这个数组的内容的

185
00:11:09,210 --> 00:11:10,650
一一致性的保障

186
00:11:10,770 --> 00:11:12,780
首先是数组中的内容

187
00:11:13,140 --> 00:11:14,250
然后其次

188
00:11:14,255 --> 00:11:18,450
啊诺夫等还记录了一些状态，比如说love的英大克斯

189
00:11:18,480 --> 00:11:20,070
考考字体的英单词

190
00:11:20,490 --> 00:11:22,950
这两个因代词的意思就是

191
00:11:23,040 --> 00:11:28,350
啊，第一个就是系统接收的最后一个写入的下标，第二个的意思是系统

192
00:11:28,355 --> 00:11:30,570
确认的最后一个写入的下标

193
00:11:30,750 --> 00:11:32,250
因为丈夫的系统

194
00:11:32,255 --> 00:11:37,560
他不仅仅要把这些写入存下来，他还要告诉客户专你的写入已经完全

195
00:11:37,565 --> 00:11:38,310
成了

196
00:11:38,790 --> 00:11:44,100
你的客户端在告诉客户端这个你的写入已经完成了的前提

197
00:11:44,105 --> 00:11:49,410
就是怨妇的，她把这个考明天应该可以，已经持久化了，这样子的话，即使掉电之后

198
00:11:49,710 --> 00:11:54,120
啊，老夫的根据自己已经考虑写的英大，科特也可以明确地知道

199
00:11:54,180 --> 00:11:59,490
客户端哪些写入是成功的，哪些写入？是啊，还没有成功的这样

200
00:11:59,970 --> 00:12:05,280
这样才能保证客户端的写入，再调电或者网络隔离的情况下不会

201
00:12:05,285 --> 00:12:06,120
流失

202
00:12:08,820 --> 00:12:11,550
然后最后看一下皮肤的的节点状态

203
00:12:12,210 --> 00:12:14,340
高富德的节点称为PR

204
00:12:14,550 --> 00:12:16,080
那么，它有三种状态

205
00:12:16,085 --> 00:12:19,740
第一个是看第一个，意味着这个节点正在进行选举

206
00:12:19,950 --> 00:12:21,600
第二个状态是好的

207
00:12:21,605 --> 00:12:25,290
低的就是就意味着这个节点他是可以进行读写的

208
00:12:25,470 --> 00:12:28,530
并且他需要给发了同步自己的状态

209
00:12:29,550 --> 00:12:34,110
最后的状态是否洛尔，也就是这个状态，他只能接收

210
00:12:34,230 --> 00:12:36,510
低点给他广播的请求

211
00:12:36,690 --> 00:12:38,280
如果他

212
00:12:38,310 --> 00:12:39,990
但是它不能进行读写

213
00:12:41,430 --> 00:12:44,250
然后最后一个要介绍的概念是离这儿特吗？

214
00:12:44,880 --> 00:12:46,080
也就

215
00:12:46,320 --> 00:12:49,200
呃，这个特殊的概念就是我们在上一页

216
00:12:49,205 --> 00:12:50,340
啊引入的

217
00:12:50,790 --> 00:12:52,530
也就是说一个

218
00:12:52,560 --> 00:12:57,870
写入它在某一个位置，他是要需要关联一个特殊目的，那么这个特么某其实就是

219
00:12:57,875 --> 00:13:02,730
是啊，里的相当于里的一个任期，她是一个逻辑始终

220
00:13:03,390 --> 00:13:07,020
比如说两个粒子同时给一个节点发送消息

221
00:13:07,110 --> 00:13:08,940
为什么会出现两个例子？

222
00:13:09,480 --> 00:13:14,790
原因是有一个离职，他认为自己是离着，但是她其实在这个分布式系统中

223
00:13:15,210 --> 00:13:18,810
他并不是真正的理解，因为并没有过半的副本

224
00:13:18,815 --> 00:13:24,120
同时认为她是离着那么这种情况下，我们就需要通过关联这一个特码

225
00:13:24,125 --> 00:13:28,530
判断到底哪一个离者具有最更高的权威性

226
00:13:32,520 --> 00:13:34,980
呃，第二部分我们来看一下

227
00:13:35,160 --> 00:13:37,440
呃，舒服特的离职选举算法

228
00:13:41,670 --> 00:13:45,120
啊，为什么需要选举呢？因为丈夫的系统

229
00:13:45,150 --> 00:13:49,080
每一个节点，他在刚启动的时候，他的状态是否勒尔

230
00:13:49,320 --> 00:13:50,820
那么它就不能读写

231
00:13:51,300 --> 00:13:53,190
额，要知道一个

232
00:13:53,280 --> 00:13:58,590
要经过一些条件之后，他们才会开始选举，选举出一个离职之后

233
00:13:58,595 --> 00:14:02,520
这个例子才能够读写，才能够响应客户端的请求

234
00:14:02,970 --> 00:14:05,580
那么具体的状态变化就是

235
00:14:05,610 --> 00:14:07,800
她一开始的状态是弗洛尔

236
00:14:08,250 --> 00:14:11,490
呃，发了呃呃，他会经过一个

237
00:14:11,495 --> 00:14:15,420
啊伊莱克斯太慢的，它会变成一个看弟弟的状态

238
00:14:15,570 --> 00:14:17,550
变成看弟弟的时候嗯

239
00:14:17,760 --> 00:14:21,900
它就会像其他的节点广播，自己的选举消息

240
00:14:22,260 --> 00:14:27,570
啊，当他收到了过半的节点的确认之后，它就会变成粒子

241
00:14:28,260 --> 00:14:33,570
变成理解之后，他就可以向其他节点广播自己的啊，最新的写入了

242
00:14:34,740 --> 00:14:36,480
然后当

243
00:14:36,900 --> 00:14:42,210
看地铁的状态的节点收到了他们更高的离地给她发送的消息时

244
00:14:42,510 --> 00:14:43,980
它就会变成发了

245
00:14:44,670 --> 00:14:45,540
这样子

246
00:14:45,810 --> 00:14:48,300
啊一轮选举之后就结束了

247
00:14:48,960 --> 00:14:51,450
那么什么时候开启第二轮选举呢？

248
00:14:51,510 --> 00:14:54,780
正常情况下啊，他当然是选举越少越好

249
00:14:54,870 --> 00:14:56,940
但是，假如说离地被隔离了

250
00:14:57,000 --> 00:15:02,010
啊芳，罗尔超过一个伊拉克逊泰茂，他没有收到了，这给他广播的心跳

251
00:15:02,220 --> 00:15:04,200
就是他会走这一条线

252
00:15:04,470 --> 00:15:06,480
超过一个以来看泰茂的时候

253
00:15:06,960 --> 00:15:11,790
发了耳机会再次进入开立的状态，然后充实通，同时发起选举

254
00:15:12,150 --> 00:15:17,070
假如说这个时候他选出了一个新的者，但是上一个低点，此时

255
00:15:17,190 --> 00:15:19,950
网络隔离被解除了，他重新加入集群

256
00:15:19,955 --> 00:15:21,510
这时会发生什么呢？

257
00:15:21,870 --> 00:15:24,480
这个就离这儿会收到心里这

258
00:15:24,630 --> 00:15:29,940
给她发送的一些消息而心里热的，特么更高，那么就离这发现之后啊！

259
00:15:29,945 --> 00:15:31,620
他就会比看我们发了

260
00:15:31,650 --> 00:15:33,150
在成为佛罗

261
00:15:34,680 --> 00:15:39,990
这个就是选举以及为什么要选举好那再选取

262
00:15:39,995 --> 00:15:41,460
的的流程中

263
00:15:42,060 --> 00:15:46,080
他是怎么判断一个p人？更应该成为一点的呢？

264
00:15:46,350 --> 00:15:48,420
他是通过特尔姆和英诺克斯

265
00:15:48,450 --> 00:15:49,590
这两个

266
00:15:49,770 --> 00:15:50,520
哎呀

267
00:15:50,790 --> 00:15:54,600
在现在选举消息内部的阶段来进行判断的

268
00:15:55,110 --> 00:15:58,890
首先，发起选举的时候，它会进入看地址的状态

269
00:15:58,895 --> 00:16:02,040
进入这个状态之后，他会把自己的项目加一

270
00:16:02,100 --> 00:16:07,410
加一之后，他就会向其他节点广播，自己的选举消息，比如说一开始

271
00:16:07,415 --> 00:16:12,720
他不知道别人的状态，那么他就会选自己，那么他就会告诉别人我在

272
00:16:12,725 --> 00:16:15,810
一个特步内，我的last音大克斯是多少？

273
00:16:15,960 --> 00:16:17,280
比如说这个地方

274
00:16:17,490 --> 00:16:18,510
Pre

275
00:16:18,780 --> 00:16:22,260
他会告诉PS2自己是在这么等于八

276
00:16:22,265 --> 00:16:25,350
里面而且自己的拉斯的一代克等于十

277
00:16:25,710 --> 00:16:30,210
然后pro她会比较这两个字段跟自己本地存的字段

278
00:16:30,600 --> 00:16:31,860


279
00:16:32,190 --> 00:16:36,120
直接的大小，她会先比较什么后比拉斯的英大克斯

280
00:16:36,810 --> 00:16:39,360
啊，假如说这个时候批准二同意了

281
00:16:39,420 --> 00:16:44,730
啊PR1对自己的投票，那么PS ii就会返回给陈某一返回卫pre

282
00:16:44,735 --> 00:16:45,960
一一个而不利

283
00:16:46,350 --> 00:16:51,660
啊，同时pre也会把自己把自己的选举消息发给p23

284
00:16:51,780 --> 00:16:53,730
但是PS3这个时候

285
00:16:54,180 --> 00:16:58,080
他的落四的，应该只是12，但是他的特码等于七

286
00:16:58,470 --> 00:17:03,780
那么这个时候啊，PS3应该投票给谁呢？他是应该投票给p21的，因为

287
00:17:03,785 --> 00:17:08,970
对比尔一的特码更高，虽然皮尔斯的落四的应该可以比比尔一更大

288
00:17:09,450 --> 00:17:14,760
这样的话，在这个系统里面，p2依旧可以收到来自p2和p23

289
00:17:14,765 --> 00:17:16,140
两个人的同意

290
00:17:16,230 --> 00:17:19,560
那么，皮尔斯在这一轮选举中就可以成为历史

291
00:17:23,490 --> 00:17:24,930
然后关于选举

292
00:17:24,960 --> 00:17:30,270
啊，有一个约束条件啊，必须要明确，就是在每一个特殊内置多

293
00:17:30,275 --> 00:17:31,500
只有一个理解

294
00:17:32,040 --> 00:17:37,350
啊，否则的话，我们回到我们之前讲讲到过的那个锤子一个

295
00:17:37,355 --> 00:17:39,180
方方洛尔，她收到了

296
00:17:39,185 --> 00:17:42,810
两个人给她发送了最新的数据

297
00:17:42,870 --> 00:17:48,180
这两份数据，他在同一个音大盖茨上，那么他应该相信谁的呢？他应该相信他

298
00:17:48,185 --> 00:17:49,650
更高的那一个人的

299
00:17:49,655 --> 00:17:51,900
假如说这两个特码一样

300
00:17:51,930 --> 00:17:55,800
那么，这就肯定会出现数据不一致的，长不一致的情况

301
00:17:57,030 --> 00:17:57,900
那么

302
00:17:58,080 --> 00:18:03,390
丈夫的丈夫算法，它如何保证每一个特么知道有一个离这儿呢？

303
00:18:04,920 --> 00:18:08,040
他是通过这样两个机制保证的

304
00:18:08,160 --> 00:18:11,760
首先，每一个屁眼在自己的特种类

305
00:18:11,765 --> 00:18:14,490
他只有没有投过票的？才能投票

306
00:18:14,670 --> 00:18:18,720
就比如说一个屁眼儿先收到他会收到两个

307
00:18:18,840 --> 00:18:21,210
最专给他发的投票请求

308
00:18:21,270 --> 00:18:25,740
假如说这两个对端发的投票请求他们的，他们的特码是一样的

309
00:18:25,745 --> 00:18:26,730
都是八

310
00:18:26,735 --> 00:18:32,040
那么这个屁眼只能响应一个第二个必然会被拒绝掉，因为她在这个特殊内已经投

311
00:18:32,045 --> 00:18:34,020
火锅嘌了，他不能再投第二票了

312
00:18:34,080 --> 00:18:35,100
这样子的话

313
00:18:35,790 --> 00:18:37,110
他就可以保证

314
00:18:37,260 --> 00:18:40,650
啊在每一个特别内只会存在一个理解

315
00:18:41,670 --> 00:18:46,050
然后同时每次投票之后都会把他耳膜和what

316
00:18:46,080 --> 00:18:49,560
就是把自己当前的项目和自己投票给的对象

317
00:18:49,650 --> 00:18:54,180
持久化起来，这样子的话，即使这个节点失败之后重启

318
00:18:54,390 --> 00:18:56,430
他也不会重新发起投票

319
00:18:57,270 --> 00:18:59,670
在这里，一个特别内重新投票一次

320
00:19:01,620 --> 00:19:06,930
然后最后关于选举要介绍的一点就是选选举算法的优化

321
00:19:08,580 --> 00:19:11,070
第一个是阮德米拉克森戴帽的

322
00:19:11,250 --> 00:19:14,580
它的作用就是避免多个方案同时

323
00:19:14,640 --> 00:19:16,680
超时，同时选自己

324
00:19:17,010 --> 00:19:18,240
同时，广播

325
00:19:18,810 --> 00:19:24,120
这样子导致的结果就是，呃，他可能要选很多很多轮，他才能选出一个力量来

326
00:19:24,630 --> 00:19:25,560
所以说

327
00:19:25,620 --> 00:19:26,760
啊，因为

328
00:19:26,765 --> 00:19:32,070
为什么呢？因为因为这些节点在选举的时候，他一开始并不知道其他节点的

329
00:19:32,580 --> 00:19:34,170
所以说，他只能选自己

330
00:19:34,175 --> 00:19:39,480
他选到自己选自己，并且广播给别人的时候，别人大一般情况下

331
00:19:39,840 --> 00:19:40,770
只能会

332
00:19:40,860 --> 00:19:46,170
更更多数情况下会拒绝掉他的这个选举消息，那么只能开启下一轮选举

333
00:19:46,200 --> 00:19:48,120
他这样子就会想出很多轮

334
00:19:49,170 --> 00:19:52,620
对于这个东西，我们是怎么解决的呢？

335
00:19:52,890 --> 00:19:55,050
我们把这个原来的形态MOD

336
00:19:55,055 --> 00:19:57,690
呃呃呃，他赋予一个随机值

337
00:19:58,080 --> 00:19:59,940
通过这样一个随机值

338
00:20:00,060 --> 00:20:00,960
唉

339
00:20:00,965 --> 00:20:03,150
就会在离地失联之后

340
00:20:03,180 --> 00:20:08,490
各个方面尔超发现发生超时进行选举的时候，有一些是先发先发

341
00:20:08,495 --> 00:20:11,070
计算机的有一些是后发计算机的

342
00:20:11,100 --> 00:20:16,410
这样子的话，嗯，先发起选举的理解点她选自己，并且把

343
00:20:16,415 --> 00:20:21,720
这个信息广播给其他人的时候，当其他人也超时也开始发起选举的时候

344
00:20:21,725 --> 00:20:27,030
因为他之前已经收到过别人发起的一些选举消息，那么她一开始就可以不同

345
00:20:27,035 --> 00:20:29,790
我自己而直接投给一个更合适的对象

346
00:20:31,770 --> 00:20:33,150
啊选举的轮数？

347
00:20:34,140 --> 00:20:39,450
第二个优化是普锐斯的，他主要解决的问题是当地的跟其他节点是

348
00:20:39,455 --> 00:20:40,470
四年之后

349
00:20:40,680 --> 00:20:43,740
其他节点重新加入集群的时候

350
00:20:44,430 --> 00:20:45,270
啊？

351
00:20:45,390 --> 00:20:48,930
会不会中断？会不会干扰整个集群的运行状态？

352
00:20:49,170 --> 00:20:50,730
就比如说嗯

353
00:20:50,790 --> 00:20:52,260
我有一个发了二

354
00:20:52,560 --> 00:20:57,150
暂时被隔离了，但是其他节点仍然是正常工作的那因为

355
00:20:57,155 --> 00:21:02,460
啊，我们失联的节点并没有超过半数，所以说这个时候绕佛的系统，它仍然是可以正常工

356
00:21:03,030 --> 00:21:05,520
到那个阶段，重新加入集群的时候

357
00:21:05,640 --> 00:21:07,650
如果没有陪过的算法

358
00:21:07,890 --> 00:21:11,430
他会把自己的父母加一，并且重新发起一轮选举

359
00:21:11,460 --> 00:21:13,890
那么理解收到他的选举消息之后

360
00:21:13,950 --> 00:21:19,260
他他就会给他们发的，然后发起一轮新的选举，也就是说，因为一个小小的节点

361
00:21:19,650 --> 00:21:21,810
整个微软的系统都被他干扰了

362
00:21:21,815 --> 00:21:24,450
啊，这个是我们不能允许的，所以说

363
00:21:24,455 --> 00:21:26,700
我们引入了一个普瑞what的阶段

364
00:21:26,940 --> 00:21:32,250
当那个节点，她失联之后，重新加入其群，它进入看地震的状态之前

365
00:21:32,790 --> 00:21:37,440
必须先进入一个普瑞看地铁的状态，在这个状态里面

366
00:21:37,500 --> 00:21:41,790
他她会先询问大家我是否可以发起一轮新的选举

367
00:21:42,000 --> 00:21:44,880
当这个时候其他节点是有利的

368
00:21:46,650 --> 00:21:49,920
那么，就会明确地告诉他，你不能发起这样的选举

369
00:21:50,340 --> 00:21:55,650
那么这个节点就可以自己老老实实的在成为发热而不干扰其他

370
00:21:55,770 --> 00:21:58,020
而不干扰整个寡妇的继续的工作

371
00:22:01,530 --> 00:22:03,750
第第三部分是嗯

372
00:22:03,870 --> 00:22:05,610
万伏特的日志复制

373
00:22:06,330 --> 00:22:11,640
我们在上一阶段解决了袜子的，他是如何选出一个可读可写的离的问题

374
00:22:12,000 --> 00:22:17,310
那么，这个可读可写的历史，就需要给其他节点广播，自己最新的

375
00:22:17,315 --> 00:22:18,180
写入

376
00:22:19,920 --> 00:22:25,110
呃，这部分我们就介绍他是如何对自己最新的写入进行广播的

377
00:22:26,850 --> 00:22:32,040
首先看一下诺夫的日志的组织方式，这个也是回顾一下我们

378
00:22:32,070 --> 00:22:34,830
在刚才介绍一个介绍过的内容

379
00:22:36,090 --> 00:22:40,530
首先，他把日志组织成一个数组，那么数组就应该有目标，对不对？

380
00:22:40,535 --> 00:22:43,560
啊，下面这一排数字，其实就是它的下标

381
00:22:43,770 --> 00:22:49,080
那么，在每一个数组中的元素，或者说叫一个写入的恩去中

382
00:22:49,085 --> 00:22:54,390
他都关联了一个自己的特点，比如说绿色的，他就是这么一黄色的，就是特么二

383
00:22:54,780 --> 00:22:56,970
啊蓝色的，她就是这么三

384
00:23:00,210 --> 00:23:04,080
啊，常规的日志复制，它是怎么进行的呢？他就

385
00:23:04,200 --> 00:23:05,520
很简单

386
00:23:05,880 --> 00:23:07,140
就可以设计出来

387
00:23:07,230 --> 00:23:08,070
比如说

388
00:23:08,100 --> 00:23:10,830
我们参考欧普的论文在里面

389
00:23:10,860 --> 00:23:12,660
呃，负债的这一张图

390
00:23:12,720 --> 00:23:13,770
这个时候

391
00:23:13,890 --> 00:23:19,200
啊，最上面的这一个日子，这个日志，他是属于当前这个特殊的例子

392
00:23:19,860 --> 00:23:25,170
然后下面这些特下面这些日子他是属于其他副本的，我们看到了，包括

393
00:23:25,175 --> 00:23:29,670
除了离队之外，它还有ABC def，还有五个副本

394
00:23:31,350 --> 00:23:34,200
啊，假如说最上面的这个节点

395
00:23:34,500 --> 00:23:37,020
他在特么等于八成为离的

396
00:23:38,430 --> 00:23:40,800
那么他当前需要广播的日志

397
00:23:41,700 --> 00:23:44,880
就应该是在殷代克斯11这个位置对不对？

398
00:23:45,600 --> 00:23:49,740
然后他就会给假如说他会给a发送一个

399
00:23:49,770 --> 00:23:51,570
呃，日志广播

400
00:23:51,575 --> 00:23:55,890
它会记录一下，就是我当前这个日志是从哪个特鲁姆开始的？

401
00:23:56,250 --> 00:23:58,500
那么当前的他他是八对不对？

402
00:23:58,530 --> 00:24:00,750
而且她的被子音单词是什

403
00:24:00,780 --> 00:24:04,830
这个被子的袋子，就是它要发送的那个ro image里面

404
00:24:04,950 --> 00:24:07,290
呃，所包含的第一个数据

405
00:24:07,440 --> 00:24:09,390
前面的那个数据的依赖克斯

406
00:24:09,420 --> 00:24:14,730
因为他现在成为离婚之后，他广播的是因袋子11这个位置的日志

407
00:24:14,735 --> 00:24:17,490
那么它的被子应该可能那就是十

408
00:24:18,180 --> 00:24:21,900
然后他发给a这个时候a发现

409
00:24:22,050 --> 00:24:22,860
自己

410
00:24:23,400 --> 00:24:28,710
啊，无法接受，因大可能等于11这个位置的日志，为什么呢？因为他发现

411
00:24:28,830 --> 00:24:31,320
自己那个4=10的地方是空白的

412
00:24:31,350 --> 00:24:32,460
那么它就会

413
00:24:32,465 --> 00:24:35,670
明确的告诉这个厉害啊，我要拒绝掉你这个消息

414
00:24:35,760 --> 00:24:39,150
为什么呢？因为我希望获得十这条日志

415
00:24:39,780 --> 00:24:41,520
那么离这就会

416
00:24:41,730 --> 00:24:45,270
从自己应该可以等于十的位置重新找

417
00:24:45,390 --> 00:24:50,700
然后找到了自己，嗯，拉夫特鲁姆等于六，并且背心代可以一九她成功的找到

418
00:24:50,705 --> 00:24:56,010
这一条是指OK，那么他就会把这条日志发送给a这个就是

419
00:24:56,015 --> 00:24:57,750
常规的日志，复制的过程

420
00:25:00,510 --> 00:25:01,350
但是

421
00:25:01,410 --> 00:25:05,250
常规的日志复制并没有解决一个问题就是

422
00:25:05,430 --> 00:25:07,440
啊日志他是可以覆盖的

423
00:25:07,740 --> 00:25:11,820
啊，为什么？呃，日志会被会产生复盖的现象

424
00:25:11,850 --> 00:25:15,270
或者说为什么发了尔他可能会有

425
00:25:15,275 --> 00:25:16,320
比例的

426
00:25:16,350 --> 00:25:18,180
更多的日志呢？

427
00:25:18,210 --> 00:25:21,480
他的原因大概是这样子的，我们还是参考这一幅图

428
00:25:21,960 --> 00:25:24,660
在特尔姆1123之内

429
00:25:24,750 --> 00:25:26,820
F，这个节点还是低的

430
00:25:27,030 --> 00:25:32,340
那么它复制了这么多条消息，一直到殷代克斯11这样的一个位置，但是在他们

431
00:25:32,345 --> 00:25:33,240
不是那

432
00:25:34,140 --> 00:25:35,670
一成为了历史

433
00:25:36,660 --> 00:25:40,230
但是他其实并没有接收到f

434
00:25:40,290 --> 00:25:42,900
在他们二和他们三类的任何日志

435
00:25:43,620 --> 00:25:45,720
但而他在他们四

436
00:25:45,725 --> 00:25:47,880
成为了离这儿，我们就发现

437
00:25:47,940 --> 00:25:53,040
在在意存活的这段期间里，他跟f ta的日子其实是一样的

438
00:25:53,070 --> 00:25:55,410
而富的日志其实是比他更多的

439
00:25:57,180 --> 00:25:59,130
原因就是这个样子

440
00:25:59,135 --> 00:26:01,440
然后其他的还有更多的一些

441
00:26:01,710 --> 00:26:02,640
啊？

442
00:26:03,330 --> 00:26:06,510
呃现象其实但是本质原因都是一样的

443
00:26:08,580 --> 00:26:10,890
那么我们遇到了日志覆盖

444
00:26:11,070 --> 00:26:16,380
或者说遇到了发了二比例的人，甚至更多的时候，我们应该怎么处理呢？我们仍然以

445
00:26:16,385 --> 00:26:18,270
这样一个图为图举例

446
00:26:19,530 --> 00:26:22,920
假如说这个时候这个离这儿给f发送日志

447
00:26:23,310 --> 00:26:24,780
他们还发现

448
00:26:24,990 --> 00:26:28,680
啊自己在因戴克斯11的位置已经有东西了

449
00:26:28,770 --> 00:26:30,210
那么她就会拒绝掉

450
00:26:30,450 --> 00:26:31,920
那么拒绝掉之后

451
00:26:32,040 --> 00:26:34,860
啊，这个节点他就会通过一个算法

452
00:26:34,980 --> 00:26:36,660
来明确地告诉你的

453
00:26:36,810 --> 00:26:42,120
啊，我想要的是因代客等于七这个位置的日志，然后这个算法

454
00:26:42,300 --> 00:26:44,880
他的详细描述是，在论文里面

455
00:26:44,970 --> 00:26:50,280
啊，我们这个地方我们可以讲的简单一点，我们只需要知道就是f ta有一种机制

456
00:26:51,000 --> 00:26:56,130
可以算出就是啊，我虽然比例这儿多日志

457
00:26:56,370 --> 00:27:01,680
可以很快地算出啊，我希望从哪个地方开始接受？而不是一个月

458
00:27:01,685 --> 00:27:03,570
一个让你这儿来试

459
00:27:04,320 --> 00:27:07,920
这样子的话，我们就可以很快地找到就是

460
00:27:07,980 --> 00:27:11,370
啊，离的真正需要给f发送日的地方

461
00:27:11,460 --> 00:27:13,980
其实就是这个因戴克斯等于四这个位置

462
00:27:14,010 --> 00:27:15,000
我们发现

463
00:27:15,060 --> 00:27:20,370
啊，我们快速地找到这个位置之后，当离子通过阴代表总数四

464
00:27:20,375 --> 00:27:25,200
这个位置给f发送一个消息时啊！

465
00:27:26,190 --> 00:27:30,270
这个离点她他在应该可以四上面它的特朗姆14对不对？

466
00:27:30,330 --> 00:27:35,640
而f这上面，虽然他的数据比离这更多，但是他们的特朗姆是二那么

467
00:27:35,645 --> 00:27:40,950
在f上面，他就可以用特殊更高的数据来覆盖是什么更低的数据？

468
00:27:42,270 --> 00:27:46,230
啊，这就是发生了日志冲突的时候的处理方式

469
00:27:46,470 --> 00:27:49,620
用特殊更高的日志覆盖成本更低的日子

470
00:27:51,180 --> 00:27:54,330
然后第三个问题是日志的确认

471
00:27:54,510 --> 00:27:56,220
啊确认是什么意思？

472
00:27:56,280 --> 00:27:59,790
啊是说当客户端发起一个写入的时候

473
00:27:59,820 --> 00:28:05,130
拉甫的系统，它向用户端确认，你这个写入已经成功

474
00:28:05,400 --> 00:28:06,510
这一个过程

475
00:28:07,710 --> 00:28:09,930
那么乱复的算法，他就要求

476
00:28:09,960 --> 00:28:15,270
只要是我向用户确认过的一个日志，他的师傅的系统里面就是

477
00:28:15,720 --> 00:28:16,650
啊？

478
00:28:16,680 --> 00:28:17,790
不能丢失的

479
00:28:18,090 --> 00:28:23,400
结合我们刚才考虑过的一个问题就是嗯，我蹲到屙数组

480
00:28:23,405 --> 00:28:28,710
日志其实是可以被覆盖的，那么被覆盖就相当于被丢失了，那么让我的心

481
00:28:28,715 --> 00:28:30,870
系统也就必然要求

482
00:28:32,220 --> 00:28:36,150
能够被之前的那个日志复制过程覆盖的日志

483
00:28:36,450 --> 00:28:38,820
一定是未被确认过的日志

484
00:28:40,050 --> 00:28:41,670
那么他是怎么做到的呢？

485
00:28:41,790 --> 00:28:44,760
啊，首先绕佛的确认一条是指

486
00:28:44,850 --> 00:28:50,160
需要过半的节点都收到了这一条日志都收到之后，她会告诉我

487
00:28:50,165 --> 00:28:52,050
我睇一阵，我已经收到了

488
00:28:52,110 --> 00:28:56,160
然后利润再汇总到足够的这样的信息之后

489
00:28:56,220 --> 00:28:57,930
她才会告诉客户端

490
00:29:00,900 --> 00:29:02,220
那么在之后

491
00:29:02,310 --> 00:29:05,250
假如说这个有点被隔离了，或者说挂掉了

492
00:29:05,310 --> 00:29:10,620
选出一个心理者，他能否覆盖他之前这个就里点之前跟客户

493
00:29:10,625 --> 00:29:15,510
却确认的日志呢，他其实是不能的，因为通过说服他的选举算法

494
00:29:15,630 --> 00:29:18,420
啊，他保证了新选出来的那个例子

495
00:29:19,290 --> 00:29:21,930
必须得到过半的节点的承认

496
00:29:22,410 --> 00:29:23,820
那么它通过

497
00:29:24,000 --> 00:29:29,310
过半节点的承认的前提就是它有最新的那一部分确认过的写入

498
00:29:30,240 --> 00:29:31,050
为少儿

499
00:29:34,440 --> 00:29:35,280
然后

500
00:29:35,520 --> 00:29:39,450
我们看到心里的已经必然包含已经确认的过程的日志

501
00:29:39,570 --> 00:29:40,590
啊OK

502
00:29:41,880 --> 00:29:44,610
然后我们会发现一个另外的新问题

503
00:29:44,700 --> 00:29:50,010
就是新的理解，它如何确认前面特么的日志

504
00:29:50,250 --> 00:29:54,960
这个地方其实是12个的算法，里面一个处理的最为特殊的一个地方

505
00:29:56,160 --> 00:30:00,750
理解了这个地方之后，基本上就是基本上软件的算法，就没有什么问题了

506
00:30:02,010 --> 00:30:03,510
我们看一下

507
00:30:03,515 --> 00:30:04,560
啊，这个图

508
00:30:05,520 --> 00:30:07,440
在特么二

509
00:30:07,770 --> 00:30:13,080
在他们一内，假如说s51点，他广播了五个消息给五个

510
00:30:13,085 --> 00:30:14,910
我们了一个消息给五个节点

511
00:30:15,540 --> 00:30:17,790
好，进入他们二之后

512
00:30:17,820 --> 00:30:22,320
Se式离职，他复制了两个数据，到s1和s2上

513
00:30:23,370 --> 00:30:25,050
然后他们三之后

514
00:30:25,260 --> 00:30:27,270
Ss 5变成了的耳机

515
00:30:27,900 --> 00:30:28,950
我们看到

516
00:30:28,980 --> 00:30:34,290
虽然s5它广播数据仍然是从特别是从英大克斯的这个位置开始

517
00:30:34,295 --> 00:30:34,950
是的

518
00:30:35,070 --> 00:30:37,770
但是，他选出的理解他必然是这么三

519
00:30:37,830 --> 00:30:38,670
为什么呢？

520
00:30:38,820 --> 00:30:42,870
因为我们之前已经说过了，所有节点在投票的时候

521
00:30:42,875 --> 00:30:48,180
他必然把自己当前任务的投票持久化起来，所以说，s5要想

522
00:30:48,185 --> 00:30:48,990
在

523
00:30:49,320 --> 00:30:54,630
要想成为历史，它必须需要s3s4s5他们三个

524
00:30:54,635 --> 00:30:55,590
全部

525
00:30:55,770 --> 00:31:01,080
啊，都投票给s5才行，因为这个地方s至少s3他是

526
00:31:01,085 --> 00:31:01,980
参与过

527
00:31:02,040 --> 00:31:06,090
啊在侧目等于二内等内一轮投票的，所以说

528
00:31:06,120 --> 00:31:09,690
至少有一个节点，它的投票是带有特别二的消息的

529
00:31:09,695 --> 00:31:15,000
所以说，在最新的议论内，如果一个节点要想成为理解，那么他

530
00:31:15,005 --> 00:31:18,180
这特么必然是大于二，也就是说，他的特种必然是三

531
00:31:18,900 --> 00:31:24,210
好s5成为离队之后，他在伊拉克斯二的这个地方

532
00:31:24,215 --> 00:31:25,680
他广播了一条日志

533
00:31:26,880 --> 00:31:30,390
然后把因戴克斯等于二的地方给覆盖了

534
00:31:31,200 --> 00:31:33,330
这个时候我们就发现

535
00:31:33,510 --> 00:31:35,760
假如说在上一个侧门内

536
00:31:36,030 --> 00:31:41,340
在在特么等于二这个离这儿，他把烟弹可等于二的写入

537
00:31:41,610 --> 00:31:44,280
广播到s 1S 2S 3之后

538
00:31:44,400 --> 00:31:47,310
这个时候他是不能够跟客户端确认

539
00:31:47,400 --> 00:31:49,740
这一条写入已经被考虑的过的

540
00:31:49,745 --> 00:31:50,940
因为我们发现

541
00:31:51,030 --> 00:31:52,620
在特步等于三

542
00:31:53,280 --> 00:31:57,300
里面s5成为低点，之后，他是仍然有可能

543
00:31:57,305 --> 00:31:57,930
吧

544
00:31:58,170 --> 00:32:01,500
啊，一带粉等于二的那个地方的写入给覆盖掉了

545
00:32:02,460 --> 00:32:07,770
所以说啊，这个地方就会出现一个问题，什么时候一个新低点

546
00:32:07,860 --> 00:32:09,390
才能确认之前

547
00:32:09,570 --> 00:32:11,820
自己前面的那些特码的日志呢？

548
00:32:12,870 --> 00:32:16,560
答案就是嗯，他成为心里的之后

549
00:32:16,565 --> 00:32:21,480
它必须广播，一条在自己父母内的一个日志，他才能

550
00:32:21,780 --> 00:32:26,970
自己特种类的日志被确认之后，他才能顺便确认前面的特别的日子

551
00:32:27,630 --> 00:32:30,690
比如说在特克斯的时候

552
00:32:30,870 --> 00:32:32,760
Se，再次成为DJ

553
00:32:32,940 --> 00:32:34,290
那么它必须

554
00:32:34,920 --> 00:32:39,300
那么，她为了尽快考斯特，自己前面收到的一些数据

555
00:32:39,360 --> 00:32:42,480
那么它就必须再广播一条自己特种类的数据

556
00:32:42,570 --> 00:32:43,530
找到

557
00:32:43,860 --> 00:32:47,040
四倍s 1S 2S 3，收到之后

558
00:32:47,190 --> 00:32:50,250
她他就会她才能够确认

559
00:32:50,340 --> 00:32:52,950
啊，特别等于二和特码等于四

560
00:32:53,040 --> 00:32:54,750
这里面的这两条数据

561
00:32:55,440 --> 00:33:00,750
这个时候如果s5再再策略，等于再在这个位置成为丽热的话，它其实就

562
00:33:00,755 --> 00:33:01,560
不能

563
00:33:02,250 --> 00:33:04,530
啊，覆盖前面的那些协议了

564
00:33:10,230 --> 00:33:13,800
这个地方就是文字解释一下，我们刚才说的内容

565
00:33:16,320 --> 00:33:21,600
然后，日志日志复制过程中最后一个要考虑的问题就是流量控制

566
00:33:21,960 --> 00:33:24,810
也就为什么我们要进行流量控制呢？

567
00:33:25,830 --> 00:33:29,580
就假如说历史啊，他一直在接收到最新的协助

568
00:33:29,820 --> 00:33:31,110
然后一个佛洛尔

569
00:33:31,290 --> 00:33:32,160
啊？

570
00:33:32,550 --> 00:33:36,000
他在接受力量给她发送的一些广播

571
00:33:36,390 --> 00:33:40,560
但是这个方案他可能落后很久了，那么离这那一端

572
00:33:40,620 --> 00:33:44,310
他既然可以通过心跳等一些机制知道这件事情

573
00:33:44,370 --> 00:33:48,090
那么它还是不是每次都要给这个发落后的弗洛尔？

574
00:33:48,180 --> 00:33:51,270
啊，给这个失联很久的发展，每次都发信息呢

575
00:33:51,275 --> 00:33:53,100
其实是不需要的

576
00:33:53,940 --> 00:33:57,840
这就是我们为什么引入留流量控制机制的原因

577
00:33:58,020 --> 00:33:59,730
一点她在

578
00:34:00,090 --> 00:34:05,400
在在离地上它为每一个方洛尔都维护了一个普通怪艾斯，就相当于一个进度

579
00:34:05,490 --> 00:34:10,800
这个进度里面主要包含两个阶段，第一个是卖卖吃的，一代词，这个就是发了

580
00:34:10,805 --> 00:34:13,020
最近一次上报的一个词

581
00:34:14,040 --> 00:34:16,110
另外一个就是那个英文字

582
00:34:16,290 --> 00:34:21,600
这个是滴滴记录的，当我下一次给某一个佛洛尔发送消息时

583
00:34:21,690 --> 00:34:25,470
啊，我需要给他发的就是开始的那个英文词

584
00:34:26,280 --> 00:34:31,590
那么，每一个啊，批发洛尔她的普拉格s有两种状态，第一个

585
00:34:31,595 --> 00:34:32,700
这是葡萄饱

586
00:34:32,790 --> 00:34:34,590
啊，这个就是探查状态

587
00:34:34,595 --> 00:34:38,310
也就是说啊，一点儿我对于你这个发了玩儿

588
00:34:38,315 --> 00:34:41,010
是否还活着啊，我信心不足

589
00:34:41,100 --> 00:34:45,420
那么我每一个他的壁纸内，我最多给你发送一条日志

590
00:34:45,510 --> 00:34:47,850
也就是说，我处于一个探察的状态

591
00:34:48,480 --> 00:34:50,130
看看你是否还活着

592
00:34:50,760 --> 00:34:53,820
然后另外一个状态是不不太可以在状态

593
00:34:53,940 --> 00:34:59,250
也就是说，离这儿却离这儿比较强的信心，觉得那个佛佬儿还活着

594
00:34:59,730 --> 00:35:00,780
那么丽这儿

595
00:35:00,785 --> 00:35:01,980
啊在？

596
00:35:02,280 --> 00:35:05,310
那么，离这儿当自己收到大量的写入之后

597
00:35:05,315 --> 00:35:10,170
呃，会不断地给这个佛洛尔啊，发送一个滑动窗口的日志

598
00:35:11,040 --> 00:35:13,440
这个窗口的大小就从卖吃的

599
00:35:13,445 --> 00:35:14,250
开始

600
00:35:14,340 --> 00:35:17,010
你知道一个啊，温度赛季

601
00:35:18,870 --> 00:35:21,750
这个温度控制，它是一个可配置的参参数

602
00:35:21,810 --> 00:35:27,000
也就是说低点，它并不需要等给芳芳姐发的每一条消息

603
00:35:27,090 --> 00:35:31,680
的回复回来之后他他才能给给宝宝发下一条

604
00:35:31,685 --> 00:35:34,530
而是在离地上维护了一个滑动窗口

605
00:35:35,580 --> 00:35:39,420
类似于TCP的滑动窗口，这样子可以极大的加快

606
00:35:39,450 --> 00:35:42,000
消息的发送效率

607
00:35:42,005 --> 00:35:45,360
同时也不会因为我发的过多

608
00:35:45,365 --> 00:35:47,640
然后导致网络拥塞，然后

609
00:35:47,790 --> 00:35:49,830
从而降低，然后它的效率

610
00:35:52,350 --> 00:35:55,200
然后前两部分介绍完了，第三部分就是

611
00:35:55,350 --> 00:35:58,410
在TK v里面，我们是怎么用vr负责的？

612
00:35:59,430 --> 00:36:01,500
首先，他有一个分片的概念

613
00:36:01,890 --> 00:36:03,720
啊，那么为什么要分片呢？

614
00:36:04,260 --> 00:36:08,040
那么，部分变形不行，那么不方便的话，那就意味着

615
00:36:08,045 --> 00:36:11,580
我全局所有的数据全部在一个怨妇的里面

616
00:36:11,700 --> 00:36:14,970
那么实际上他是失去了一个水平，扩展性的对不对？

617
00:36:15,510 --> 00:36:17,340
因为一个我让不得的话

618
00:36:17,345 --> 00:36:19,680
我们三副本的话，他就只有三节点

619
00:36:19,710 --> 00:36:23,340
那那么假如说我们有更多的机器，我们就只有

620
00:36:23,345 --> 00:36:27,030
把把她画成一个新的肉肉的，那么其实这个是

621
00:36:27,660 --> 00:36:32,970
相当于进行了一个垂直拆分，而不是一个水平拆分，那么就意味着它其实是

622
00:36:32,975 --> 00:36:33,990
失去了

623
00:36:33,995 --> 00:36:35,490
啊，水平扩展性的

624
00:36:36,780 --> 00:36:39,690
那么我们考虑竟然要分片

625
00:36:39,780 --> 00:36:42,150
就需要有各种各样的策略

626
00:36:42,270 --> 00:36:46,620
她他kv里面支持的一个策略是按表现分嗯

627
00:36:47,100 --> 00:36:50,520
这个也是内置的AD b里面的一个策略

628
00:36:51,060 --> 00:36:56,370
也就是说，泰币泰迪b里面每一张数据表都会对应到OK c端的

629
00:36:56,375 --> 00:36:58,260
一个月间

630
00:36:59,760 --> 00:37:02,670
然后第二个策略是根据大小切分

631
00:37:02,850 --> 00:37:07,950
根据大小切分这个就涉及到啊kk微端的两个配置参数

632
00:37:07,955 --> 00:37:11,250
一个是瑞森麦克斯赛斯，一个是瑞士斯比利的赛季

633
00:37:12,720 --> 00:37:15,600
啊，通过这两个参数，我们就可以控制

634
00:37:15,750 --> 00:37:20,130
啊kkv对于对大瑞镇进行此不利的

635
00:37:20,190 --> 00:37:25,470
则不利的之后，它会变成一些比较小的睿智，这样子我们就可以避免大的急诊

636
00:37:25,590 --> 00:37:27,690
导致的写入热点

637
00:37:30,570 --> 00:37:33,390
然后纷纷骗相关的一些卖出去

638
00:37:33,780 --> 00:37:36,660
啊，这个是在kk TT TT

639
00:37:36,900 --> 00:37:38,850
啊，这个面板下面

640
00:37:38,910 --> 00:37:40,530
啊卡拉斯科这一行

641
00:37:40,950 --> 00:37:42,720
然后你的这个咋弄？

642
00:37:44,040 --> 00:37:47,490
啊，我们看到这个，这个集群，他其实只有一个

643
00:37:47,580 --> 00:37:50,610
啊，只有一个tak v节点，所以说它只有一条线

644
00:37:50,640 --> 00:37:55,950
我们看这个例子，她他的个数我们是通过判断一个节点上，嗯，这儿的个数

645
00:37:56,460 --> 00:37:57,450
来判断

646
00:37:59,010 --> 00:38:01,170
在不同的Ikv节点上

647
00:38:01,200 --> 00:38:03,330
啊，他的历史是否平衡？

648
00:38:04,350 --> 00:38:08,520
然后第二个图，他是在同一个页面同一行下面

649
00:38:08,670 --> 00:38:10,350
啊它是有一个锐阵

650
00:38:10,680 --> 00:38:12,450
他同样也是看个数

651
00:38:13,890 --> 00:38:15,870
假如说这个图里面

652
00:38:15,875 --> 00:38:21,180
有多个太kv，然后他们的离队的个人件的个数，或者说离队的个数

653
00:38:21,185 --> 00:38:26,490
很不均匀的话，那么可能这个激情就有一些问题需要我们今生需要我们

654
00:38:26,495 --> 00:38:30,060
CBA同学进行一些更进一步的查看

655
00:38:31,800 --> 00:38:35,280
然后第二个内容就是分配的合并

656
00:38:35,520 --> 00:38:40,830
啊，为什么我们要进行分配的合并呢？像上面一样，就是我把一些大型建材城

657
00:38:40,835 --> 00:38:42,450
一些小的分配不好吗？

658
00:38:42,960 --> 00:38:44,940
啊，其实这个涉及到就是

659
00:38:46,020 --> 00:38:51,330
比如说我们对表进行一些迪迪的数据的操作，或者说我们干脆把表进行

660
00:38:51,335 --> 00:38:52,140
不掉了

661
00:38:52,230 --> 00:38:54,150
那么，那些历史数据

662
00:38:54,360 --> 00:38:59,370
他们就会留下大量的空滤震，或者说里面数据很少的危险

663
00:39:00,330 --> 00:39:03,420
过多的追求会降低他可以为了性能

664
00:39:03,510 --> 00:39:06,930
所以说，我们在k KC 20版本之后

665
00:39:06,935 --> 00:39:08,940
引入了就是这样子的特性

666
00:39:09,210 --> 00:39:11,730
然后对于墨子的控制是通过

667
00:39:11,940 --> 00:39:14,160
下面这两个pd的参数

668
00:39:14,370 --> 00:39:15,390
进行控制的

669
00:39:16,020 --> 00:39:21,330
第一个参数，意思就是说，当我最近的大小小于20到7

670
00:39:21,335 --> 00:39:24,000
之后我就要考虑将他们没儿子起来了

671
00:39:24,120 --> 00:39:29,430
第二个参数的意思是说，当一个睿智的p的个数小于20万个的时候，我也

672
00:39:29,435 --> 00:39:31,200
要考虑把他墨迹起来了

673
00:39:32,250 --> 00:39:35,250
就通过我们通过车之末日的机制

674
00:39:35,280 --> 00:39:39,270
啊就解决了一些大量残存的小睿智，或者是控制器的问题

675
00:39:40,530 --> 00:39:43,020
然后最后介绍一下

676
00:39:43,140 --> 00:39:44,610
啊在？

677
00:39:45,450 --> 00:39:48,960
啊，在KTV里面没有t life的相关的一些

678
00:39:48,965 --> 00:39:51,270
更多的性能，相关的卖去死

679
00:39:52,950 --> 00:39:54,690
啊首先

680
00:39:54,695 --> 00:39:56,970
如何处理多个丈夫的消息？

681
00:39:57,300 --> 00:40:00,390
啊，我们之前的讨论都是局限于

682
00:40:00,690 --> 00:40:01,560
啊？

683
00:40:01,620 --> 00:40:06,150
三个重复的就比如说单个衣服的给另外一个丈夫的发送一些选取消息

684
00:40:06,240 --> 00:40:08,820
或者说嗯，日志复制的消息

685
00:40:10,230 --> 00:40:11,760
然后这个时候

686
00:40:11,820 --> 00:40:16,290
这个地方我们看一下他kk他是如何处理多个寡妇的消息的

687
00:40:16,740 --> 00:40:19,140
在二点几版本的中

688
00:40:19,170 --> 00:40:23,850
啊箬铺的嗯OK a是通过一个单线程，我们称为刷不到四到县城

689
00:40:24,510 --> 00:40:27,750
来处理所有睿智的抓捕的消息

690
00:40:27,960 --> 00:40:31,290
我们就是200万的一个一个区，然后

691
00:40:31,530 --> 00:40:35,460
所有消息在一个管道中，我们顺序取出执行

692
00:40:35,465 --> 00:40:36,720
啊，但是

693
00:40:36,870 --> 00:40:40,380
呃，单线程，他就容易成为瓶颈，所以说我们在三

694
00:40:40,470 --> 00:40:42,210
啊3 ds版本内

695
00:40:42,390 --> 00:40:47,190
我们为我们为我们将拉斯特斯道改造成了一个多项城的组件

696
00:40:48,030 --> 00:40:50,250
每一个锐阵自己有一个管道

697
00:40:50,430 --> 00:40:52,080
同时，每一个锐阵

698
00:40:52,110 --> 00:40:57,420
啊，一次性可以被处理的消息个数，我们给大家设置了一个上线，这样就避免了

699
00:40:58,140 --> 00:41:01,860
啊，一个很方面繁忙的微信不断地得到被处理

700
00:41:01,950 --> 00:41:04,860
而且他的椎枕啊，出现饥饿的现象

701
00:41:06,930 --> 00:41:08,070
然后之后

702
00:41:08,160 --> 00:41:10,740
呃消息的后续处理

703
00:41:11,430 --> 00:41:16,740
对于算法的节点，每一个推荐她都会产生一些磁盘写入

704
00:41:17,010 --> 00:41:22,320
我们通过上面这这些机制啊，每一个睿智的一批消息，然后

705
00:41:22,325 --> 00:41:23,370
处理之后

706
00:41:23,430 --> 00:41:28,110
将多个乡镇共同产生的磁盘写入批量写入磁盘中

707
00:41:28,770 --> 00:41:31,590
然后再批量处理他们的IO和网络

708
00:41:31,620 --> 00:41:34,590
这样子，通过一些批处理的方式来提高性能

709
00:41:34,800 --> 00:41:36,810
而不是对于每一个瑞典

710
00:41:36,815 --> 00:41:40,560
只单独处理他自己的东西，单独落盘单独写网络

711
00:41:41,550 --> 00:41:43,170
然后最后

712
00:41:43,230 --> 00:41:46,170
啊是将丈夫的消息处理完成之后

713
00:41:46,260 --> 00:41:50,430
将它发送到耳廓来县城这个地方，我们是类似于

714
00:41:50,640 --> 00:41:51,540
啊？

715
00:41:51,990 --> 00:41:54,480
这一部分也是有一些

716
00:41:55,050 --> 00:41:56,460
啊，办事极致的

717
00:41:56,670 --> 00:41:59,340
啊，然后我们再饿破烂完成之后

718
00:41:59,370 --> 00:42:02,610
啊才返回给客户端你的写入已经成功了

719
00:42:04,260 --> 00:42:05,700
然后

720
00:42:05,760 --> 00:42:08,370
下一个主题是如何替课多个@@

721
00:42:09,870 --> 00:42:11,820
首先是为什么我们要替课

722
00:42:12,030 --> 00:42:17,340
TT刻的原因就是因为我们院服的里面它是有各种各样的超时的比例

723
00:42:17,345 --> 00:42:20,370
比如说哈，隔壁的泰帽子和伊拉克逊泰帽子

724
00:42:21,420 --> 00:42:24,810
也就是说，我必须要我为了要驱动一个润肤的镜头

725
00:42:24,900 --> 00:42:26,310
啊的正常工作

726
00:42:26,315 --> 00:42:30,120
必须要设置一些定时器，在外面去驱动这个舒服的

727
00:42:30,360 --> 00:42:32,250
的逻辑失踪往前走

728
00:42:33,510 --> 00:42:35,010
所以说，我们就要

729
00:42:35,130 --> 00:42:39,810
每隔一段时间来TIC他那么相相关的tak v的配置

730
00:42:40,050 --> 00:42:45,330
就是首先让他的贝斯特和英特尔等于一淼，也就是说，对于每一个椎枕

731
00:42:45,335 --> 00:42:47,880
我们要每一个一秒去tx他一次

732
00:42:48,960 --> 00:42:54,270
当比如说这是一个佛洛尔，那么我们TIC她之后，她达到了自己的以来，克森泰

733
00:42:54,275 --> 00:42:54,960
骂他

734
00:42:54,990 --> 00:42:57,840
那他就知道自己已经跟李姐失恋很久了

735
00:42:57,845 --> 00:42:59,730
那么他就可以发起一次选举

736
00:42:59,850 --> 00:43:02,850
如果没有这个基础的话，那么他是无法发生这

737
00:43:03,030 --> 00:43:04,740
无法发现这一件事情的

738
00:43:05,610 --> 00:43:09,120
然后他的b的TF=2啊什么意思呢？

739
00:43:10,050 --> 00:43:11,730
就是他每隔二秒

740
00:43:11,790 --> 00:43:12,570
会

741
00:43:12,630 --> 00:43:14,730
这个2×1秒就等于二秒

742
00:43:14,850 --> 00:43:19,590
也就是说，他每隔二秒会尝试给其他节点发送一个哈尔滨

743
00:43:20,700 --> 00:43:23,490
然后伊莱克斯泰茂的等于十

744
00:43:23,495 --> 00:43:24,480
那么就是

745
00:43:24,510 --> 00:43:25,470
啊他？

746
00:43:25,530 --> 00:43:30,840
发了尔格德额超过十秒没有收到离队的消息之后，他就会发现

747
00:43:30,845 --> 00:43:32,130
一轮新的选举

748
00:43:33,570 --> 00:43:37,110
那么，我们在t可没有t12伏的的时候

749
00:43:37,140 --> 00:43:40,530
我们就会面临一个问题，当时正过多的情况

750
00:43:40,535 --> 00:43:45,840
一次即可，所需要的工作就越多，比如说你一个太kv实体上

751
00:43:45,845 --> 00:43:47,190
有十万个睿智

752
00:43:47,195 --> 00:43:49,170
那么，你再一次替课之内

753
00:43:49,175 --> 00:43:51,000
你就要对十万个椎枕

754
00:43:51,750 --> 00:43:56,820
去改他抓捕的内部的状态，如果需要选举的话，再生成一条发选举消息

755
00:43:56,825 --> 00:43:57,720
发送出去

756
00:43:58,770 --> 00:44:00,510
这样子的话，他一次即可

757
00:44:00,570 --> 00:44:05,040
可能的时间就会长，那我们在运维过程中如何解决这个问题呢？

758
00:44:05,310 --> 00:44:08,550
这首先单击如果超过一万个锐阵

759
00:44:08,555 --> 00:44:10,470
项目就要提高警惕了

760
00:44:10,620 --> 00:44:14,730
因为可能这个会导致整个sky它的性能下降

761
00:44:15,630 --> 00:44:17,760
然后在二点

762
00:44:17,765 --> 00:44:19,020
还是版本中？

763
00:44:19,260 --> 00:44:23,790
我们就需要通过修改，然后他被佩佩和英特尔来降低影响

764
00:44:27,120 --> 00:44:32,430
然后最后是没有去曲阜的相关的一些性能，magic，我们看到可以看到

765
00:44:32,490 --> 00:44:36,060
首先是不不太唠嗑，佐为是这个是在

766
00:44:36,360 --> 00:44:38,280
大概月底会有这个大肆报道

767
00:44:38,400 --> 00:44:40,470
然后抓住lo这一行

768
00:44:40,560 --> 00:44:43,320
然后最后是iPad的主人翁

769
00:44:43,350 --> 00:44:44,850
啊，这个面板里面

770
00:44:45,960 --> 00:44:49,620
她记录了平均点九五还有点九九

771
00:44:49,680 --> 00:44:53,190
啊，老夫的数据写入kv恩静的时间

772
00:44:53,820 --> 00:44:57,000
另外还有一个非常相似的喷喷的log的时间

773
00:44:57,330 --> 00:45:01,230
啊，这两个时间同样记得是iPhone是指点九五和点九九

774
00:45:01,740 --> 00:45:05,220
如果我们观察这两个没有面板，它的时间很高的话

775
00:45:05,250 --> 00:45:10,500
那就说明啊，威伏特系统乱复的系统，它的写入压力很大

776
00:45:10,530 --> 00:45:11,880
那么就要考虑

777
00:45:12,480 --> 00:45:13,920
是否在这个地方？

778
00:45:13,925 --> 00:45:16,080
啊，存在系统的性能瓶颈

779
00:45:16,085 --> 00:45:18,090
如果我们需要得到更高一个性能

780
00:45:18,390 --> 00:45:21,270
的话，那么我们就要考，可能就要考虑

781
00:45:21,360 --> 00:45:26,280
啊，在这一部分加入更多的线呢？或者说这直接加入更多的实力

782
00:45:27,690 --> 00:45:30,750
啊，这个地方可以看到是一个

783
00:45:30,780 --> 00:45:31,980
稍微四位置

784
00:45:32,010 --> 00:45:37,200
啊，什么意思呢？就按照我们之前的描述啊，乱乱的的写入

785
00:45:37,320 --> 00:45:41,400
呃，我们是从一个大的管道里面，将每一个睿智的

786
00:45:41,430 --> 00:45:44,460
呃，最新的写入拿出来，然后把它写到磁盘上

787
00:45:44,520 --> 00:45:49,290
上面一个监控介绍了每一次写入她大概要花多长时间？

788
00:45:49,380 --> 00:45:50,460
上面假如说

789
00:45:50,465 --> 00:45:55,770
每一次写入她的话，花的时间都比较长，那么是不是后面的写入都在那个管道里面拍？

790
00:45:55,775 --> 00:45:56,490
对对的

791
00:45:57,210 --> 00:45:58,620
从从这个监控

792
00:45:58,710 --> 00:46:00,570
刷POS为他的睿智

793
00:46:01,080 --> 00:46:02,460
我们就可以看到

794
00:46:03,030 --> 00:46:05,550
这些写入在管道里面排队的时间

795
00:46:07,200 --> 00:46:12,030
这个时间同样都是同样也是记录了iPhone 2952点九九的

796
00:46:13,290 --> 00:46:17,130
啊，下面一个也跟上面的一个非常类似

797
00:46:17,190 --> 00:46:20,160
他是在额plus那个管道里面等待的时间

798
00:46:20,400 --> 00:46:25,620
如果这这个时间和上面的那个时间都比较高的话，那同样也就意味着

799
00:46:26,730 --> 00:46:31,440
我们的院服的写入系统，它存在一个比较严重的性能瓶颈

800
00:46:31,650 --> 00:46:33,540
也就是说通过

801
00:46:33,660 --> 00:46:35,580
这四幅图的监控

802
00:46:35,730 --> 00:46:37,380
我们就可以知道

803
00:46:37,530 --> 00:46:42,840
啊，一个系统，如果它写入比较多的话，他的平静是否出现在拉萨的德？

804
00:46:44,520 --> 00:46:45,930
最后

805
00:46:45,960 --> 00:46:49,650
假如说我们确定了平静，在这个地方，我们应该怎么解决呢？

806
00:46:52,110 --> 00:46:56,310
啊有两个相关的配置，这两个配置，它是在

807
00:46:56,370 --> 00:47:01,380
啊噗噗的3 dx版本中的首先是242破赛斯和布赖破扇子

808
00:47:01,680 --> 00:47:06,510
到破晒死就对应着上面的噗噗赖log主任参和

809
00:47:06,540 --> 00:47:08,130
把它泡死，我也想出去现在

810
00:47:08,430 --> 00:47:13,740
不赖哦，不赖破塞子就对应的下面的老婆，赖主任，审核尔扑赖慰

811
00:47:13,745 --> 00:47:14,700
跳出一声

812
00:47:16,530 --> 00:47:18,660
当上面两个监控

813
00:47:18,780 --> 00:47:21,090
啊，出现了非常高的

814
00:47:21,150 --> 00:47:24,030
啊延迟的话，我们就可以修改这两个配置

815
00:47:24,060 --> 00:47:25,920
来达到一个比较高的性能

816
00:47:27,300 --> 00:47:32,610
但是，在224版本下，我们其实我们是没有这两个参数的，所以说我们就只能

817
00:47:32,615 --> 00:47:35,550
考虑通过扩容太kv实例数

818
00:47:35,640 --> 00:47:38,580
或者说扩容机器数量来解决瓶颈问题

819
00:47:40,170 --> 00:47:42,210
以上就是

820
00:47:42,300 --> 00:47:45,240
啊绕复制复制状态机的主要内容

821
00:47:45,600 --> 00:47:46,740
然后谢谢大家

822
00:47:51,450 --> 00:47:52,050
我不知道

