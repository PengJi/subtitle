1
00:00:00,030 --> 00:00:05,340
嗯嗯嗯嗯嗯

2
00:00:13,470 --> 00:00:17,010
今天给大家分享的泰迪有浩气的一个原理

3
00:00:17,820 --> 00:00:23,130
然后先自我介绍一下我叫要姚克楠，然后是瓶盖这边的一个研发工程

4
00:00:23,135 --> 00:00:23,790
十

5
00:00:23,910 --> 00:00:27,390
主要是负责和CF优化器相关的一些工作

6
00:00:27,540 --> 00:00:30,150
然后之前曾经就职于

7
00:00:30,180 --> 00:00:31,800
结果怎么和那个腾讯？

8
00:00:31,920 --> 00:00:34,560
我国人碰到我随口内核的开发

9
00:00:36,990 --> 00:00:42,300
然后今天的课程的一个概要是所以从学习目标上是

10
00:00:42,960 --> 00:00:47,940
了了解他利弊优化器的原理，然后帮助大家去做c口调优

11
00:00:48,090 --> 00:00:53,400
然后这个课程的受众的话，是需要对数据库原理有一定基础的人员

12
00:00:53,405 --> 00:00:55,200
时长大概是70分钟

13
00:00:55,830 --> 00:00:57,960
关键的一个知识点是

14
00:00:58,110 --> 00:01:00,180
第一方面是泰迪的价格

15
00:01:00,240 --> 00:01:03,600
第二方面的话，可以介绍优化器的原理包括

16
00:01:03,605 --> 00:01:05,520
逻辑化和物理优化

17
00:01:05,700 --> 00:01:09,210
然后再介绍一下执行计划，缓存这个功能

18
00:01:12,000 --> 00:01:14,910
进进入课程的第一部分，他利弊的价格原理

19
00:01:15,000 --> 00:01:18,720
这部分的一个嗯，首先会介绍一下学习目标

20
00:01:18,750 --> 00:01:20,640
然后介绍学习的内容

21
00:01:20,850 --> 00:01:24,180
内容主要包括他对比整个的价格是怎样的

22
00:01:28,650 --> 00:01:29,820
然后

23
00:01:29,880 --> 00:01:34,200
他的随口曾在整个价格中处理，就是一个什么样的位置上面

24
00:01:34,320 --> 00:01:37,110
然后最后再次介绍一下优化器这个模块

25
00:01:39,630 --> 00:01:44,940
啊，首先是学习目标目标的话，第一步是回顾一下整整体的一个

26
00:01:44,945 --> 00:01:45,990
玉的价格

27
00:01:46,260 --> 00:01:47,130
然后

28
00:01:47,135 --> 00:01:50,370
包括它的水口长以及它的存储层

29
00:01:50,375 --> 00:01:51,390
然后以及

30
00:01:51,450 --> 00:01:54,180
随口从中主要包含了一些模块是哪些？

31
00:01:54,360 --> 00:01:59,100
然后再了解一下整个优化器在这个收购成功的位置以及功能

32
00:02:01,290 --> 00:02:04,620
这是一个非常经典的，它就变成一个架构图

33
00:02:04,830 --> 00:02:06,270
大概是氛围

34
00:02:06,275 --> 00:02:11,580
胎胎壁卡塔尔和存储层这边的是kv或者是纯纯主人的下面

35
00:02:11,880 --> 00:02:17,190
对面的可以为以及为为了做那个大数据计算了一个18块的一个

36
00:02:17,195 --> 00:02:20,520
情然后他们中间是通过和

37
00:02:20,910 --> 00:02:26,220
批批地的话，它会存一些元数据的信息，然后泰迪b的话会和批地通信区

38
00:02:26,225 --> 00:02:27,600
获取一个

39
00:02:27,660 --> 00:02:30,360
接收或者是数据的一个分布信息

40
00:02:30,540 --> 00:02:33,570
然后再去才开微去取那个真正的数据

41
00:02:36,300 --> 00:02:39,450
然后泰迪BC构成的话，就主要是指

42
00:02:39,540 --> 00:02:43,560
啊，这个这张图里面的左下角那个泰迪变的一部分

43
00:02:44,460 --> 00:02:49,320
结构层也主要包括两个部分，第一部分是一个协议层

44
00:02:49,350 --> 00:02:52,680
协议层的是主要是兼容的是买随口的一个协议

45
00:02:52,685 --> 00:02:55,740
然后处理的是一些网络通信这方面的一些

46
00:02:56,160 --> 00:02:58,290
基本的那种功能

47
00:02:58,830 --> 00:03:01,800
然后核心这块的话就是整个的c口曾

48
00:03:01,860 --> 00:03:05,490
这个从的话，从这个流程上来看的话，包括

49
00:03:05,610 --> 00:03:06,930
这块的解析

50
00:03:06,960 --> 00:03:12,270
然后随口的一个去验证，以及进入优化，其中做逻辑优化

51
00:03:12,275 --> 00:03:13,320
和物流化

52
00:03:13,440 --> 00:03:18,750
然后根据统计信息的话，会选出一个最优的执行计划，然后扔到那个泰利必

53
00:03:18,755 --> 00:03:20,490
执行器里面去执行

54
00:03:21,810 --> 00:03:24,210
然后这个曾还包括了

55
00:03:24,240 --> 00:03:29,550
其他的一些功能性的模块，比如说做权限管理或者是坐滴滴

56
00:03:29,555 --> 00:03:31,530
和司马相关的一些管理

57
00:03:31,710 --> 00:03:35,850
还有一个CC和那个后台的一些呃

58
00:03:36,120 --> 00:03:38,550
作为功能性的那种后台县城

59
00:03:40,950 --> 00:03:46,260
然后把c口曾把c口中中比较重要的那部分给抠出来的话就是

60
00:03:46,740 --> 00:03:47,880
包括爬山

61
00:03:47,940 --> 00:03:48,870
以及

62
00:03:49,170 --> 00:03:51,240
用优化器以及执行器

63
00:03:54,060 --> 00:03:57,270
然后我们进入第二部分就介绍优化器整个的一个原理

64
00:03:57,480 --> 00:04:01,890
这部分的话，也是分成几个点的介绍，第一个是学习目标

65
00:04:01,895 --> 00:04:05,940
第二个是学习内容，内容包括整个优化器的一个概述

66
00:04:06,030 --> 00:04:07,260
然后是

67
00:04:07,320 --> 00:04:12,630
在进入优化器之前的一个预处理这么一个阶段，主要是做一些什么事情？

68
00:04:12,930 --> 00:04:18,150
然后就是优化器核心步骤中的罗基化合物，硫化两个两部分

69
00:04:18,780 --> 00:04:24,090
然后我们在最最后的话还会回顾一下，嗯，学习目标以及整个过程中的一个

70
00:04:24,150 --> 00:04:25,230
关键的知识点

71
00:04:28,500 --> 00:04:31,950
首先看学习目标这一张主要的一个

72
00:04:32,250 --> 00:04:37,170
目标是了解液化气，需要解决一个什么样的问题，为什么需要优化器？

73
00:04:37,320 --> 00:04:42,480
然后对优化器的一个产出，也就是执行计划，有一个感性的一个认识

74
00:04:43,110 --> 00:04:47,250
然后了解一下啊，优化器预处理阶段，他做的事情是什么？

75
00:04:47,550 --> 00:04:51,480
然后就是熟悉常用的一些逻辑化阶段用到的规则

76
00:04:51,600 --> 00:04:54,150
然后以及理解物理优化的一个原理

77
00:04:56,910 --> 00:04:58,680
首先是优化器的概述

78
00:04:58,920 --> 00:05:04,230
计划器的定义是在一个合理的时间内找到一个合理的执行者

79
00:05:04,235 --> 00:05:04,890
话

80
00:05:05,040 --> 00:05:07,710
那么第一个问题就是，什么是执行计划？

81
00:05:09,090 --> 00:05:10,470
这里给出一个例子

82
00:05:10,500 --> 00:05:12,450
左边是一个ch语句

83
00:05:12,570 --> 00:05:13,500
是

84
00:05:13,650 --> 00:05:15,780
两张表之间做一个之外

85
00:05:15,840 --> 00:05:20,130
然后就问之后的话再说，有一个第二表，顺便的一个过滤条件

86
00:05:21,570 --> 00:05:25,800
然后这个做出来的一个执行计划的话，就是类似于这样一棵树

87
00:05:25,920 --> 00:05:30,120
这棵树里面的每一个节点都是一个关系代数的一个节点

88
00:05:30,270 --> 00:05:33,960
像底层的节点的话，就是做表的一个扫描

89
00:05:33,990 --> 00:05:38,190
然后这里有一个表表的一个选择就是做

90
00:05:38,340 --> 00:05:40,350
对对表进行一些过滤

91
00:05:40,440 --> 00:05:45,750
然后这里有一个集那个连接操作，把两张表给连接起来，最后再做了一个

92
00:05:45,755 --> 00:05:48,780
投影操作，因为我们这种结果只需要

93
00:05:48,785 --> 00:05:54,090
Te和t2的其中的某一个列，所以不需要把全部的那个数据都返回给

94
00:05:54,095 --> 00:05:58,200
客户专专，这就是大概的一个执行计划的一个长相

95
00:06:03,870 --> 00:06:04,680
然后

96
00:06:04,770 --> 00:06:10,080
一条c口的话，它其实可能对应的是很多种的执行计划，所以优化

97
00:06:10,085 --> 00:06:12,270
这就需要在这个

98
00:06:12,360 --> 00:06:16,470
很多种的执行计划里面去选择一个在执行层

99
00:06:16,500 --> 00:06:21,810
或者是在运行时的时候是性格非常好的一个执行计划，为什么说有？

100
00:06:21,815 --> 00:06:24,420
一条CK可能会有多种的执行计划

101
00:06:25,020 --> 00:06:25,770
就是

102
00:06:25,950 --> 00:06:31,260
比如说，他这里有很多的饿为度，都会导致这条西裤有很多的执行计划

103
00:06:31,265 --> 00:06:32,520
一四

104
00:06:32,525 --> 00:06:35,520
关系代数的那些算子是否是可以下推？

105
00:06:35,910 --> 00:06:37,080
然后第二次

106
00:06:37,140 --> 00:06:40,080
我可能面临的是一个表上有很多个，所以

107
00:06:40,200 --> 00:06:45,510
然后我不同的，所以选择的话，会导致不同的执行计划，然后连接和聚合

108
00:06:45,515 --> 00:06:50,820
和这种稍微复杂一点的关系，大数算子他有不同的实现的一个方法

109
00:06:51,240 --> 00:06:56,550
然后就是仔查询怎么去处理职查询有很多种不同的方法？然后也会导致不同的职业

110
00:06:56,555 --> 00:06:58,020
你们计划

111
00:07:02,730 --> 00:07:03,330
我想知道

112
00:07:04,410 --> 00:07:09,720
然后第二步就是第二个要介绍的就是在一个查询真正的从

113
00:07:09,990 --> 00:07:15,300
它是里头被解析了之后，到进入优化器之前，他需要做的一个

114
00:07:15,305 --> 00:07:19,350
预处理的这个步骤，他第一步要做的事情就是

115
00:07:20,220 --> 00:07:25,530
做一个嗯，就是去判断当前的这个查询是否可以走一个

116
00:07:25,535 --> 00:07:30,840
企业经就是通过优化气质而直接产生一种比较简单的执行计划这一位

117
00:07:31,110 --> 00:07:35,160
简单的特殊的执行计划，就叫做坡坡特即使检查

118
00:07:35,370 --> 00:07:40,680
满足就是能够产生检查这种执行计划，查询需要满足一些

119
00:07:40,685 --> 00:07:45,990
条件第一个条件就是它只能是单表上面的水来可

120
00:07:46,140 --> 00:07:48,150
而对称或者是底内侧

121
00:07:48,180 --> 00:07:49,260
就第一个条件

122
00:07:49,290 --> 00:07:52,680
第二个同时需要满足的条件是他的

123
00:07:52,770 --> 00:07:57,390
查询里头涉及到的过滤条件必须是一个点查

124
00:07:57,420 --> 00:08:02,730
也就是说，它过滤条件完了之后，他最多只能够返回一条记录

125
00:08:03,090 --> 00:08:04,560
或者是零条记录

126
00:08:05,160 --> 00:08:07,950
做这个检查的一个好处是

127
00:08:07,955 --> 00:08:13,260
我们可以跳过，如果我们检查出这个查询负责符合了颇文字概括这种

128
00:08:13,265 --> 00:08:18,570
条件的话，我们就可以跳过优化器里，造成整个优化的步骤，然后这部分是

129
00:08:18,600 --> 00:08:20,700
可以节省很多的开销

130
00:08:20,730 --> 00:08:26,040
然后第二个就是我们单独为这里查询，把他识别出来，然后做了

131
00:08:26,045 --> 00:08:31,350
一个比较高效的那种执行器的一个实现，所以它在运行，首先就是它可以听

132
00:08:31,355 --> 00:08:36,660
跳过优化器的这个开销，然后第二是它在运行时执行器中，它也会有个比较

133
00:08:36,690 --> 00:08:38,190
高效的方式去运行

134
00:08:40,770 --> 00:08:46,080
然后第第二部减假如说我们检查当前的这个查询他不满足喷

135
00:08:46,085 --> 00:08:50,580
列的条件，那么我们就会开始就是进入就是在

136
00:08:50,610 --> 00:08:55,920
为进入优化器而做准备，这一不准备就是我会去构造一个

137
00:08:55,925 --> 00:08:58,620
初始的一个逻辑的执行计划

138
00:08:58,860 --> 00:09:04,170
逻辑执行计划，她的构造方式是一个自底向上的一个

139
00:09:04,175 --> 00:09:06,930
过程啊，因为我在他是

140
00:09:06,935 --> 00:09:12,240
结果里头我会保留啊，我当前查询中，涉及到的各个

141
00:09:12,245 --> 00:09:13,530
字段的一些

142
00:09:13,590 --> 00:09:15,240
内容或者是属性

143
00:09:15,245 --> 00:09:20,550
就比如说我一个查询里头涉及到了有哪些表，然后这个表上面

144
00:09:20,555 --> 00:09:22,980
的话，我有哪些选择的条件？

145
00:09:23,040 --> 00:09:27,930
然后我用到了真正的最后的需要返回给用户的那些列是什么？

146
00:09:28,320 --> 00:09:33,630
然后我就会根据相应的这一些，嗯，记录下来的内容，或者是字段

147
00:09:33,960 --> 00:09:38,040
自底向上的去把一颗初始的执行计划构造出来

148
00:09:39,240 --> 00:09:40,500
然后在这里的话

149
00:09:40,650 --> 00:09:43,020
优化其实就已经从这里开始了

150
00:09:43,980 --> 00:09:44,940
比如说

151
00:09:45,330 --> 00:09:48,540
几个举几个优化的例子就是？

152
00:09:48,840 --> 00:09:50,610
第一个是常量折叠

153
00:09:50,910 --> 00:09:52,260
常用折叠就

154
00:09:52,620 --> 00:09:57,930
承认的意思就是假如说我的查询里头涉及到有表达式

155
00:09:57,990 --> 00:09:59,040
或者是

156
00:09:59,045 --> 00:10:01,680
呃，用户自定义的一些函数

157
00:10:02,040 --> 00:10:07,350
而且这个函数的一些参数的话，他都是产量，那么我可以在

158
00:10:07,560 --> 00:10:12,870
优化器这个预处理的阶段，就把这个表达式的结果给直接执行出来，并且

159
00:10:12,875 --> 00:10:13,830
存在

160
00:10:13,835 --> 00:10:15,390
这个要执行计划里头

161
00:10:15,450 --> 00:10:20,760
然后你后面的话就没有必要去把这个整个表达式带到后面去做优化了

162
00:10:21,570 --> 00:10:23,130
这是第一步，常量折叠

163
00:10:23,340 --> 00:10:25,890
第二部是表达式的一个软件

164
00:10:26,190 --> 00:10:28,350
所有的表达式的化简是指

165
00:10:28,830 --> 00:10:30,900
比如说

166
00:10:31,080 --> 00:10:36,000
我有一个表达式是以弗纳尔，然后其中第一个参数是一个劣

167
00:10:36,005 --> 00:10:41,310
然后第二个参数和第三个参数是两个变量，那么就表明是当我第一个

168
00:10:41,315 --> 00:10:45,690
列为null值的时候，我返回第二个参数

169
00:10:45,750 --> 00:10:51,060
如果第一个烈不满足那样的话，我返回第三个参数，这就是这种这类表达式的一个行业

170
00:10:51,810 --> 00:10:53,400
那么我其实可以在

171
00:10:53,790 --> 00:10:59,100
这一个阶段预处理的阶段，我去检查当前的那个第一个参数的列

172
00:10:59,400 --> 00:11:04,710
她的她他的符号位上是否标记为说我当前列永远不可能

173
00:11:05,040 --> 00:11:06,420
包含null值

174
00:11:06,660 --> 00:11:11,970
如果有这个东西的话，有这个符号位设置为争论的话，那我就可以把整个表达式直接

175
00:11:11,975 --> 00:11:13,350
借给简化成

176
00:11:13,355 --> 00:11:18,570
第二个第第三个跖就是第三个边上那个直来代替掉整个表达式

177
00:11:19,170 --> 00:11:23,430
这是第二个优化，第三个就是对于姊查询的优化

178
00:11:24,000 --> 00:11:24,900
这查询

179
00:11:24,990 --> 00:11:30,300
整个介绍起来会比较麻烦一点，然后我在这里的话，只是简单的介绍，感兴趣

180
00:11:30,305 --> 00:11:33,660
这个同学可以下来的话，看一下我们之前写过的

181
00:11:33,750 --> 00:11:37,410
啊，原码阅读的那个文章里面介绍的会比较详细一些

182
00:11:37,680 --> 00:11:42,990
查查询一般来说，我们会把他嗯，有几种选择方式来处理它

183
00:11:43,170 --> 00:11:47,100
第一种是如果这个仔查询是一个非相关的紫砂壶

184
00:11:47,160 --> 00:11:50,340
但我可以在预处理这个阶段直接把

185
00:11:50,610 --> 00:11:52,950
那个咖啡相关的这个仔查询

186
00:11:52,955 --> 00:11:58,260
把它执行出来，把结果给替换掉，紫杉军本身以前所在的位置就是第一

187
00:11:58,265 --> 00:11:59,400
处理方式

188
00:11:59,610 --> 00:12:03,180
第二种处理方式，我把仔查询，转换成一个

189
00:12:03,510 --> 00:12:08,280
表和表之间的连接就是紫砂群众的表和紫砂壶外面的表的一个连接

190
00:12:09,900 --> 00:12:12,690
连接的话，正常情况下来说的话是

191
00:12:12,695 --> 00:12:18,000
看看你的那个仔查询的连接查询的那个表达式的类型是什么？

192
00:12:18,005 --> 00:12:23,310
有的是，比如说应加上一个子查询，有的是一个角色，或者是大于或者是等于这些

193
00:12:23,730 --> 00:12:27,000
然后如果是对于举个例子就是以印来为例的话

194
00:12:27,030 --> 00:12:28,590
他就会处理成一个

195
00:12:28,680 --> 00:12:30,300
谁你就很这种形式？

196
00:12:30,540 --> 00:12:35,850
然后把也就是说把子查询中的表和纸查询外面的表做一个鲜明

197
00:12:35,855 --> 00:12:36,540
一种

198
00:12:36,810 --> 00:12:39,900
然后我们这个也做过一个优化就是如果

199
00:12:39,905 --> 00:12:45,210
查询是一个非相关的查询的话，那我可以把这个心里转换给转换成一个

200
00:12:45,600 --> 00:12:47,310
几点之外然后？

201
00:12:47,400 --> 00:12:52,710
只是说这个英语作文是一个比较特殊的一个英文，我需要在仔查询那一端的话去做一

202
00:12:53,010 --> 00:12:55,320
聚合并且去从这个逻辑

203
00:12:55,890 --> 00:12:58,740
然后如果对于其他类型的

204
00:12:58,860 --> 00:13:04,170
啊，只要学习，比如说非相关的资料的话，我们一般会把它做成一个粽子，叫做

205
00:13:04,175 --> 00:13:05,340
哦，plus算算

206
00:13:05,430 --> 00:13:07,680
所有的我落扇子，它是一类

207
00:13:07,710 --> 00:13:09,240
特殊的一个，就问

208
00:13:09,300 --> 00:13:10,110
他的

209
00:13:10,115 --> 00:13:12,930
它相比于普通的做爱的话，他的

210
00:13:13,020 --> 00:13:14,550
特殊之处就在于

211
00:13:14,700 --> 00:13:16,770
它依赖于外层

212
00:13:16,830 --> 00:13:22,140
那个表传进来一个参数，然后我才能够执行内存的一个整个的执行计划

213
00:13:22,290 --> 00:13:23,610
也就是说他在

214
00:13:23,760 --> 00:13:26,940
实现的角度上来说的话，他只能够用

215
00:13:27,090 --> 00:13:32,400
循环嵌套的那种实现连接的方法，而不能够用像其他的，像他需要或者是

216
00:13:32,405 --> 00:13:34,560
是应对可能他不准这种方法

217
00:13:39,270 --> 00:13:40,050
我不知道

218
00:13:40,620 --> 00:13:41,970
然后进入

219
00:13:42,090 --> 00:13:47,400
经过刚才的恶语处理那一部之后，我们已经构造出了一颗初始

220
00:13:47,405 --> 00:13:52,710
的逻辑执行计划，那么就正式进入到优化器的这个步骤中

221
00:13:52,715 --> 00:13:55,020
第一个步骤就是逻辑文化

222
00:13:55,110 --> 00:13:56,790
所有的牢记优化就是

223
00:13:56,795 --> 00:14:00,660
我根据我构造出来的这个执行计划

224
00:14:00,665 --> 00:14:04,560
来选择哪些我可以试用去

225
00:14:04,800 --> 00:14:08,520
去那个恶仆落上去的一些逻辑化的规则

226
00:14:09,000 --> 00:14:14,310
而且这个up LA e的方式是一个顺序的不太一然后这里列出了我们目前支持

227
00:14:14,315 --> 00:14:16,170
存在一些逻辑化的规则

228
00:14:16,380 --> 00:14:17,490
第一个是

229
00:14:17,520 --> 00:14:20,310
列检查所有的列检查就是

230
00:14:20,400 --> 00:14:24,810
啊，刚才那个例子其实已经已经提到过了我上层的蒜子

231
00:14:24,900 --> 00:14:30,210
可能并不需要下层把所有的列都返回上来，我只需要我返回其中某一部分的

232
00:14:30,870 --> 00:14:33,120
然后这个实现的方式就是

233
00:14:33,660 --> 00:14:38,970
根据钢材构造出来那一颗逻辑优化的那个逻辑逻辑逻辑

234
00:14:38,975 --> 00:14:44,280
执行计划，那颗树，然后我自顶向下的便利，这棵树在美颜

235
00:14:44,285 --> 00:14:46,920
一个关系代数的节点上面的话

236
00:14:47,220 --> 00:14:52,530
我去统计出我当前节点需要哪些列作为

237
00:14:52,535 --> 00:14:53,490
输入

238
00:14:53,495 --> 00:14:58,800
然后并且把这个值给累计起来，把把这个信息累计起来，传给我的

239
00:14:58,805 --> 00:14:59,730
子节点

240
00:14:59,735 --> 00:15:05,040
然后一层一层传下去，把所有的节点需要的列都给统计了起来，然后

241
00:15:05,045 --> 00:15:06,000
最终我

242
00:15:06,270 --> 00:15:11,580
到更节点的时候，我就只需要去返回向上返回我上次曾杰

243
00:15:11,940 --> 00:15:14,940
需要的这些猎而不是所有人1度返回上去

244
00:15:15,630 --> 00:15:18,420
第二个优化规则是分区剪裁

245
00:15:18,810 --> 00:15:24,120
因为我们现在支持了分区表，这个功能啊，分区表的话，有哈哈

246
00:15:24,125 --> 00:15:27,060
息分分合合暗润积分区

247
00:15:27,180 --> 00:15:32,490
容易按日期分区为例假如说我一个表他呃呃

248
00:15:32,495 --> 00:15:35,640
对面的有三个分区表示不同的分段

249
00:15:35,645 --> 00:15:40,950
那么我有一个查询查询，在这张表上面有一个过滤条件，我可以根据这个过滤调

250
00:15:40,955 --> 00:15:46,260
间和我分区本身的那个定义的条件来剪裁掉那些永远

251
00:15:46,265 --> 00:15:49,980
不可能放那个满足我的过滤条件，那些分区

252
00:15:49,985 --> 00:15:51,780
然后让那个

253
00:15:52,170 --> 00:15:56,970
让底层参与整个执行计划执行的那些数据量会减少

254
00:15:58,080 --> 00:16:00,990
第三个优化规则是叫聚合消除

255
00:16:01,200 --> 00:16:06,510
聚合消除就是我们在执行计划里面会有一些聚合函数啊，然后聚合函数

256
00:16:06,515 --> 00:16:11,820
会如果带了，估计这一个语句的话，相当于是我在每一个分组里头

257
00:16:11,825 --> 00:16:14,010
这个基础上去计算这个

258
00:16:14,160 --> 00:16:19,470
去了函数那么如果我的工作不在那上面就有了一个

259
00:16:19,475 --> 00:16:21,030
唯一性的属性的话

260
00:16:21,270 --> 00:16:24,330
比如说像抗体或者是上午这种的话

261
00:16:24,335 --> 00:16:26,970
那么我就可以直接把整个的

262
00:16:26,975 --> 00:16:32,280
聚合函数给消除或者是改写成另外的一些表达式，而不用去做

263
00:16:32,285 --> 00:16:33,090
这个

264
00:16:33,120 --> 00:16:35,190
分组之后再聚合这个逻辑

265
00:16:36,420 --> 00:16:40,170
然后如果再聚合和第四条规则是

266
00:16:40,530 --> 00:16:45,840
Match函数和幂函数的一个优化，其实迈克尔命就是一类特殊的聚合函数

267
00:16:46,200 --> 00:16:50,400
如果在第三条中聚合，消除中，我们没有把麦克斯命给

268
00:16:50,490 --> 00:16:55,800
给给优化掉的话，我这第四部分单独的考虑一下她所有的迈克逊的优化就是

269
00:16:57,120 --> 00:17:01,020
麦克斯和麦克斯戴尔麦克斯和命的那种

270
00:17:01,350 --> 00:17:06,660
聚合函数的，查询的话，可以被转化成or败，加上厘米乘一的方式

271
00:17:08,130 --> 00:17:13,440
就比如说我谁来客，麦克斯一个列夫上面一个退步的话，就是选择这一列里头最大的

272
00:17:13,445 --> 00:17:18,750
大的那个值那我其实可以把这个列按照降序排序

273
00:17:19,050 --> 00:17:23,940
然后选择排在第一个的那个厘米te就是返回那第一第一条记录

274
00:17:24,360 --> 00:17:25,710
这个好处就是

275
00:17:26,040 --> 00:17:27,240
好处就是说

276
00:17:27,360 --> 00:17:32,670
如果我用迈克尔命这种聚合函数的方式的话，我需要把所有的数据从下

277
00:17:32,675 --> 00:17:34,200
她曾给

278
00:17:34,620 --> 00:17:39,930
从他们比如说从太空非常给拿到，他就BB1层，然后我再去做，把所有

279
00:17:39,935 --> 00:17:45,240
这个列都给参与做一次那个聚合函数的那个逻辑，但如果我把它转化成

280
00:17:45,510 --> 00:17:50,820
获得外加上一个恋美色的话，那我的word by可能会被就是我的表现，如果定义

281
00:17:50,825 --> 00:17:56,130
应该可以的话，那我们这个词就已经保证了这个我world by需要的这个属性

282
00:17:56,135 --> 00:17:56,730
经

283
00:17:56,735 --> 00:18:02,040
所以在这种情况下的话，我我去扫描那个应该不是我只需要去

284
00:18:02,045 --> 00:18:07,350
第一条记录我就可以把整个查询就完成了，就相比于我之前买的命运

285
00:18:07,355 --> 00:18:11,670
要把所有的记录都从他可以拿到的金币来做，这样性能会高很多

286
00:18:13,710 --> 00:18:16,440
然后第五条规则是投影消除

287
00:18:16,500 --> 00:18:20,520
投影消除现在是按照两个阶段来做的

288
00:18:20,580 --> 00:18:22,710
所有的投影消除就是

289
00:18:23,100 --> 00:18:28,410
如果我的执行计划里头有普通截屏，也就是投影这么一个算子的

290
00:18:28,415 --> 00:18:30,030
好，我会去判断

291
00:18:30,300 --> 00:18:35,610
我这个普洱截屏是不是有必要的？这两种情况下，这个破机器是没有必要的

292
00:18:36,000 --> 00:18:41,310
第一种就是我的复杂点，我这个当钱算出来负节点告诉我，我这个破

293
00:18:41,315 --> 00:18:45,210
这也是没有必要的，就比如说我连续有两个普捷克

294
00:18:45,360 --> 00:18:47,850
说这个现在自己也是一个普及次

295
00:18:47,910 --> 00:18:48,810
因为我

296
00:18:48,840 --> 00:18:54,150
在对于姊节点的那个普洱精品，我做完这个投影之后的话，我再在上层的时候

297
00:18:54,155 --> 00:18:59,460
还要再做一次，那我其实就没有必要做下面这一层，这个投影操作，我们直接做

298
00:18:59,465 --> 00:19:02,580
这上面这个这一层的图片操作就可以了，所以

299
00:19:02,640 --> 00:19:07,950
如果我的负节点告诉我姐姐说我这个头像可以被消除掉，那我可以把它把自己给

300
00:19:07,955 --> 00:19:09,360
给这个团给消除掉

301
00:19:09,960 --> 00:19:12,900
呃，适用于这条规则的

302
00:19:13,230 --> 00:19:18,540
场景的话，一个就是我刚才介绍的啊，上次是普洱茶样品测试这些方式

303
00:19:18,840 --> 00:19:24,150
还有一种是项城市艾维尔培训下城市的普通行政方式，或者是上层的是温度方式

304
00:19:24,155 --> 00:19:29,460
沙尘是普洱这种种方式，它本质上其实都是说因为艾薇儿培训或者是温州风险

305
00:19:29,465 --> 00:19:32,730
本质上都是做了一个类似于投影这种操作

306
00:19:32,910 --> 00:19:38,220
也就是说，我上层还需要再做一次同意，所以我下层这个节点就不要，没有必要再做一次

307
00:19:38,850 --> 00:19:40,380
就是第这是第一种情形

308
00:19:40,590 --> 00:19:45,900
第二种是用于投影消除的情形就是我的子节点告诉我这个复杂点

309
00:19:46,170 --> 00:19:51,480
说你这个复杂点，可以被消除掉，这种情况是我们现在的代码中的事

310
00:19:51,485 --> 00:19:53,220
现在的话，他是在

311
00:19:53,850 --> 00:19:59,160
物理优化完了之后，内部的就做了，其实它本质上是一个逻辑的话的一个内容

312
00:19:59,460 --> 00:20:01,170
它的原理就是

313
00:20:01,200 --> 00:20:04,470
如果我的这个普通截屏操作的话

314
00:20:04,710 --> 00:20:05,370
多

315
00:20:05,580 --> 00:20:07,620
我把那个如果我的输出

316
00:20:07,650 --> 00:20:12,960
已经满足了，我记得我下午几点我的子节点的输出已经满足了我们？

317
00:20:12,965 --> 00:20:18,270
所以需要的那个最终的那个输出的话，那我这个投影操作本身是一个多余的，没有意思

318
00:20:18,275 --> 00:20:19,080
这东西

319
00:20:19,260 --> 00:20:20,730
所以我就可以把消除掉

320
00:20:20,735 --> 00:20:26,040
为什么会产生这样的一类的普洱？这个一类似我们在构建那个

321
00:20:26,100 --> 00:20:27,480
初始的那颗

322
00:20:27,485 --> 00:20:29,430
逻辑话术的时候

323
00:20:29,490 --> 00:20:32,610
和那个逻辑执行计划树的时候，我们会

324
00:20:32,640 --> 00:20:37,560
在顶层节点会加一个破解器来作为最终结果的一个

325
00:20:37,620 --> 00:20:42,930
一个投投影的一个返回，另外另另外一种情形是我们在优化

326
00:20:42,935 --> 00:20:48,240
记得中间过程中会去添加不同类型的，都会去跟

327
00:20:48,245 --> 00:20:53,550
不同的类型的那个优化规则里头会去添加一些投影操作，然后有一些

328
00:20:53,555 --> 00:20:54,570
那时候你操作

329
00:20:54,600 --> 00:20:59,910
在最终看来，应该可能就是一些荣誉的，所以我们在这一步的话，需要把这些这种鱼的头

330
00:20:59,915 --> 00:21:00,660
去掉

331
00:21:02,250 --> 00:21:06,780
然后第六条的一个优化规则是，外联家的消除

332
00:21:06,930 --> 00:21:09,480
等下我会具体以例子来介绍

333
00:21:09,540 --> 00:21:14,850
这部分就是标红的这几条逻辑化规则的话，都会在后面的例子来具体这些少数以

334
00:21:15,060 --> 00:21:16,800
现在就先略过他

335
00:21:17,550 --> 00:21:22,080
然后下一条就是外联家转折连接，然后这个也是等一下介绍

336
00:21:22,110 --> 00:21:24,660
然后就是只查询的去关联

337
00:21:24,960 --> 00:21:30,270
所有的子查询区块链就是我们刚才介绍说在啊构造初始

338
00:21:30,275 --> 00:21:32,850
那个逻辑执行计划的时候

339
00:21:32,855 --> 00:21:36,930
对于姊查询的话，我们会把它构造成一个啊plus算是

340
00:21:37,020 --> 00:21:42,330
然后她他的左右两端的话，是它的外层表和那个仔查询中涉及到的

341
00:21:42,690 --> 00:21:48,000
那么嗯，这个时候的话，因为刚才说她和普通的，就问你的区别就

342
00:21:48,005 --> 00:21:50,850
就是它在实现的时候，他只能够以

343
00:21:50,970 --> 00:21:56,280
循环嵌套的方式去实现，而循环签到，一般来说的话，在执行过程中他

344
00:21:56,340 --> 00:22:01,650
不是一个最高效的这种方式，所以我们希望能够把出出来，尽可能的去

345
00:22:01,655 --> 00:22:05,520
转换成普通的砖，然后我在后续考虑

346
00:22:05,610 --> 00:22:08,220
就是实现的时候我才能有个更多的选择

347
00:22:08,820 --> 00:22:14,130
去关联就是这个过程，就是把出出来转换成普通之后，你这样一个方式去关联的一个路

348
00:22:14,135 --> 00:22:15,030
这就是

349
00:22:15,270 --> 00:22:18,990
我想把下层节点涉及到

350
00:22:19,050 --> 00:22:23,280
就是相关猎人那些那些表达式或者是蒜子

351
00:22:23,285 --> 00:22:28,290
给往上提提到这个连接操作，因为我破坏本身是一个特殊的连接

352
00:22:28,320 --> 00:22:30,420
提到这个连接操作网上

353
00:22:30,660 --> 00:22:34,650
就是它的上层节点上面去，如果我可以把他提上来的话

354
00:22:34,680 --> 00:22:35,430
那么

355
00:22:35,910 --> 00:22:37,860
我的整个连接

356
00:22:38,550 --> 00:22:43,860
整个连接及其他的网下的一些籽几点的话？它其中都没有在

357
00:22:43,865 --> 00:22:48,660
包含相关列，所以这个时候它就是一个普通的一个点击操作，我就可以

358
00:22:48,665 --> 00:22:50,130
把它转化成普通的绝望

359
00:22:50,880 --> 00:22:52,500
一个例子就是

360
00:22:53,400 --> 00:22:56,370
比如说我仔查询里头涉及到了一个

361
00:22:56,880 --> 00:22:57,870
威尔条件

362
00:22:57,930 --> 00:23:00,810
然后为这个威尔条件的话，他是

363
00:23:02,280 --> 00:23:04,080
他是那个相关链

364
00:23:04,770 --> 00:23:10,080
相关列，然后这个时候我可以把这个写了，请这个选择给作为我

365
00:23:10,085 --> 00:23:12,690
两个表做卷子的一个

366
00:23:12,720 --> 00:23:18,030
去问看看，写就就是专用的条件，然后给放到铺plus算子里头本身去了这个是

367
00:23:18,035 --> 00:23:20,370
时候我再来看我扑来

368
00:23:20,460 --> 00:23:25,770
不太算子本身都虽然它包含有那个相关链，但是它的子节点已经不包含相关练了

369
00:23:26,100 --> 00:23:29,430
这个时候的话，我就可以把这个ARP LA转换成一个普通的

370
00:23:31,440 --> 00:23:36,750
然后下一条是谓词下推，这个也是怎样介绍聚合下推，还有就是

371
00:23:36,755 --> 00:23:38,610
后门和厘米尺的下垂

372
00:23:38,970 --> 00:23:44,280
拖班和莉莉的下去，这里的整个这里逻辑化规则中涉及到的这个下推的话

373
00:23:44,285 --> 00:23:46,050
都是指的是在

374
00:23:46,950 --> 00:23:49,800
这个计算层的下垂不是

375
00:23:49,830 --> 00:23:54,750
不是把这个算式从计算丞推到物理推到那个存储成趣

376
00:23:54,780 --> 00:23:59,490
因为那个是后续的，后续还会再介绍吧，这里的托盘和厘米上的话就是

377
00:23:59,850 --> 00:24:05,160
我想把托福分算子，或者是另外一个算法推到离我的数据源其实

378
00:24:05,165 --> 00:24:08,910
就是底层的得到寿司这个算式越近的地方越好

379
00:24:08,970 --> 00:24:12,300
因为如果我我我往下，我越往下推的话

380
00:24:12,390 --> 00:24:17,700
整个上层参与计算的数据的函数就会越少，这样的话

381
00:24:17,705 --> 00:24:22,170
也会加快我整个执行计划的一个执行执行的一个效率

382
00:24:23,460 --> 00:24:25,920
然后就是连接顺序的调整

383
00:24:26,190 --> 00:24:28,530
再给上面再详详细的介绍

384
00:24:31,830 --> 00:24:37,140
现在就是分例子来介绍刚才红色标红部分的那些逻辑的话，规则

385
00:24:37,470 --> 00:24:41,640
第一个就是外联接转类连接以及位置下推

386
00:24:42,150 --> 00:24:44,610
以这个查询为例，他是

387
00:24:44,730 --> 00:24:45,750
体表

388
00:24:45,930 --> 00:24:47,820
左外连接t2标

389
00:24:47,825 --> 00:24:53,130
然后有两个还有一个条件问的条件是test=t2的t1，然后他有

390
00:24:53,280 --> 00:24:58,590
两个条件威尔条件，第一个是t一个班，60大于11，第二，第二个是第二个是外表大于

391
00:24:58,680 --> 00:24:59,730
大约22

392
00:25:00,960 --> 00:25:02,880
然后我们构造出来的

393
00:25:02,910 --> 00:25:08,220
原始的一个初始的一个逻辑的执行计划就是TT代表作上面

394
00:25:08,225 --> 00:25:13,140
然后然后做一个雷夫斯基外，然后再在上面去过这个两个非标的

395
00:25:13,830 --> 00:25:14,700
但是呢？

396
00:25:15,150 --> 00:25:16,800
我可以把它改写成

397
00:25:16,860 --> 00:25:17,910
像一种方式

398
00:25:18,210 --> 00:25:21,510
这个区别就是我把类似的，只要改成了婴儿之外

399
00:25:21,540 --> 00:25:26,850
为什么我可以把累？所以直接改改改成为一个婴儿的，因为根据累死之后

400
00:25:26,855 --> 00:25:27,780
我的定义

401
00:25:27,900 --> 00:25:33,210
如果我t仪表在t2表中，如果能够找到匹配，我就把

402
00:25:33,215 --> 00:25:36,420
整个作为匹配起来的一个结果输出出去

403
00:25:37,020 --> 00:25:37,860
如果

404
00:25:38,280 --> 00:25:39,210
T仪表

405
00:25:39,270 --> 00:25:44,580
不能够在第二表中找到匹配，我会对体表也会输出，只是说在

406
00:25:44,585 --> 00:25:48,420
T2的那部分去补的是拉饵直进去

407
00:25:48,900 --> 00:25:51,660
然后如果我上层的feel特里面

408
00:25:51,690 --> 00:25:54,210
包含了婴儿表的一个

409
00:25:54,390 --> 00:25:59,700
条件，并且这个音列表的条件，如果它的值为null的话，这个菲尔特

410
00:25:59,705 --> 00:26:01,170
永远不能满足

411
00:26:01,175 --> 00:26:03,600
这个时候，我们称这种条件为

412
00:26:03,605 --> 00:26:05,400
那我们直接可以的就是

413
00:26:05,970 --> 00:26:10,890
只要第二只要婴儿表的职位，那我这个条件，她永远都为负时

414
00:26:10,895 --> 00:26:16,200
如果这种情况满足的话，我其实可以把那次作业直接转向因为因为

415
00:26:16,320 --> 00:26:18,270
如果我说的就是

416
00:26:18,570 --> 00:26:20,730
没有匹配产生的那些

417
00:26:20,790 --> 00:26:26,100
结果她的所有的婴儿婴儿裂的话他都是拉着直，然后她永远都过不了那个

418
00:26:26,105 --> 00:26:31,410
那我其实就没有必要把这部分的结果给输出出去了，我直接就是因而作为这个

419
00:26:31,415 --> 00:26:34,410
可以了，我直接把能够

420
00:26:34,560 --> 00:26:38,370
匹配到的那个ta和t2表那个数据返回上去就可以了

421
00:26:39,480 --> 00:26:41,130
所以第一步我就可以把

422
00:26:41,135 --> 00:26:43,560
类似的改成了一个婴儿转

423
00:26:44,310 --> 00:26:49,620
然后这个查询还可以进一步利用未迟下推那个优化规则给改写

424
00:26:49,625 --> 00:26:51,060
成下面这种形式

425
00:26:51,390 --> 00:26:56,700
就把t156大于11和t二点外六大于22点分别吓退

426
00:26:56,705 --> 00:26:57,360
到

427
00:26:57,600 --> 00:27:01,620
把那个推过，就问这个节点推到tel和t2表上面去

428
00:27:02,460 --> 00:27:04,350
这样的话，好处就是

429
00:27:04,380 --> 00:27:07,020
我参与作案的整个

430
00:27:07,025 --> 00:27:12,330
左表和右表的那个数据量都会大大的减少，这样我整个因为其实在执行过

431
00:27:12,335 --> 00:27:17,640
其中就问是一个非常耗时的操作，如果我能够把周二参参与周日的数据量减

432
00:27:17,645 --> 00:27:21,390
我的话，我就能够提升整个职执行计划的一个执行速度

433
00:27:26,100 --> 00:27:28,260
然后第二个例子是

434
00:27:28,265 --> 00:27:32,400
聚合下推聚合下推这里需要嗯

435
00:27:32,820 --> 00:27:34,590
需要解释的一点是

436
00:27:34,595 --> 00:27:35,730
一般来说

437
00:27:35,790 --> 00:27:41,040
逻辑优化规则有一个原则就是他是一个等价的一个变化

438
00:27:41,130 --> 00:27:43,560
然后一般来说也是一个

439
00:27:43,800 --> 00:27:48,000
产生的应用，这条逻辑化规则之后，产生的结果

440
00:27:48,150 --> 00:27:49,350
一定会比

441
00:27:49,620 --> 00:27:53,910
之前的那个结果，在实现层来说，它会更优

442
00:27:54,030 --> 00:27:56,520
但是这里有一个例外，就是这个逻辑的话

443
00:27:56,910 --> 00:28:01,290
他并不一定会产生一个更好的一个结果啊！

444
00:28:01,800 --> 00:28:02,880
你这个例子

445
00:28:03,150 --> 00:28:04,290
我们也是

446
00:28:04,320 --> 00:28:05,820
有两张表坐坐

447
00:28:05,850 --> 00:28:10,440
提问之后的话，按照t ET t做了一个礼拜做分组

448
00:28:10,470 --> 00:28:14,010
分组再在每一个分组上面去求踢一点外流的值

449
00:28:15,540 --> 00:28:20,850
然后这个是构造出来的，初始的一颗逻辑执行计划TXT

450
00:28:20,855 --> 00:28:24,630
第二代表作一个音乐圈，然后后面有一个聚合算聚合算子

451
00:28:25,710 --> 00:28:29,880
啊，我可以把这个聚合算子给推过音乐之外

452
00:28:30,120 --> 00:28:31,230
把他放到

453
00:28:31,830 --> 00:28:33,090
T，仪表这种啦！

454
00:28:33,960 --> 00:28:34,890
也就是说

455
00:28:34,950 --> 00:28:37,440
我把这个聚合给拆成了两段

456
00:28:37,620 --> 00:28:39,570
第一段是在外表上

457
00:28:39,750 --> 00:28:44,820
按照踢的替我做了一次分组，然后把踢的歪了给求了出来

458
00:28:45,210 --> 00:28:47,550
然后这里这里头发输出的话就是

459
00:28:47,760 --> 00:28:53,070
这个算子的输出就是t ET和t2t和t ET e的那个外流，然后我再和

460
00:28:53,075 --> 00:28:54,270
和t2的表

461
00:28:54,275 --> 00:28:55,080
按照

462
00:28:55,140 --> 00:28:58,350
这个梯一梯的梯和梯二的可以做一次机会

463
00:28:58,620 --> 00:28:59,880
转的结果

464
00:28:59,885 --> 00:29:00,960
再按照

465
00:29:01,080 --> 00:29:06,390
这个本身的这个聚合里头，按照题的题再做一次分组，再做一次聚合

466
00:29:07,170 --> 00:29:09,600
这个逻辑上，它是一个等价的

467
00:29:09,630 --> 00:29:14,250
然后如果为什么我们想要把这个聚合给下推过去？

468
00:29:14,280 --> 00:29:18,450
也是和刚才那个原因是一样的，我想把参与做的

469
00:29:18,720 --> 00:29:20,700
这个表的数量给

470
00:29:20,880 --> 00:29:25,020
减少啊，不是表达数量，就是参与一万的表的行数减少

471
00:29:25,500 --> 00:29:28,050
然后这样的话，我可以提升整个中文的效率

472
00:29:28,200 --> 00:29:33,510
所以这里就涉及到刚才我提到的那个，这条规则他并不一定会产生一个

473
00:29:33,570 --> 00:29:36,540
更优的执行结果，因为你这里

474
00:29:36,750 --> 00:29:39,120
T表先做了一次，聚合之后

475
00:29:39,150 --> 00:29:40,620
她分组的数量

476
00:29:40,800 --> 00:29:46,110
这个函数有多少？其实是取决于你本身踢的踢的这个数据分布的

477
00:29:46,890 --> 00:29:47,700
如果

478
00:29:47,760 --> 00:29:49,110
踢了踢她的

479
00:29:49,140 --> 00:29:51,180
就是n TV，也就是叫

480
00:29:52,710 --> 00:29:53,640
就是

481
00:29:53,730 --> 00:29:57,930
第四，性格外表就是不同的值，他非常多的话

482
00:29:58,080 --> 00:30:03,390
极端情况下就是它每一个值，她都是一个不同的值，这种情况下的话，你其实做

483
00:30:03,395 --> 00:30:08,700
这一次失败的话，你的分组的数量和你本身踢的那个函数是一

484
00:30:08,705 --> 00:30:14,010
是的，然后你并不能够减少中文节点的函数的输入，而且你

485
00:30:14,015 --> 00:30:17,760
还引入了一个额外荣誉的一个聚合这么一个步骤

486
00:30:18,270 --> 00:30:21,510
就会导致他整个经济话可能并不是

487
00:30:21,660 --> 00:30:24,720
执行起来的时候，并没有就是不下推那么快

488
00:30:25,440 --> 00:30:30,750
所以我们目前把这条规则做了一个开关来控制我在

489
00:30:30,755 --> 00:30:36,060
逻辑的时候是否去应用这条规则，然后默认的这条规则是没有被打开的

490
00:30:36,120 --> 00:30:41,430
然后这里还有一点要注意的就是整个聚合他能够背下推有意

491
00:30:41,435 --> 00:30:43,320
这个条件就是

492
00:30:43,440 --> 00:30:44,910
不办你这个

493
00:30:44,970 --> 00:30:49,500
必必须是军用t里头这个裂的一个超级

494
00:30:49,650 --> 00:30:53,130
就是比如说我估计71

495
00:30:53,160 --> 00:30:58,470
ACE，或者是按按的那个t一点c2就是按两列来做这个故事

496
00:30:58,475 --> 00:31:03,780
的话，那我也可以把这个下去下去，但如果我这里只是条件是有两个列，比如说踢

497
00:31:03,785 --> 00:31:09,090
C点ce等于第二点can n ten ce=c二点c2，但是我姑姑的话就是一定

498
00:31:09,095 --> 00:31:14,400
这这个时候我是没有办法把这个聚合给下推下去的，因为这样的话你不能保证

499
00:31:14,405 --> 00:31:16,350
我这上面的结果的一个正确

500
00:31:19,590 --> 00:31:22,050
然后第三个例子就是外连接的消除

501
00:31:22,740 --> 00:31:28,050
所谓的外连接，消除就是我把外连接整个从执行计划里头

502
00:31:28,055 --> 00:31:31,740
也一定把就把这个连接操作整个从执行劲往里面一跳

503
00:31:32,160 --> 00:31:34,140
因为像刚才这里的话，是吧？

504
00:31:34,320 --> 00:31:35,970
第一个例子，里头是吧？

505
00:31:36,360 --> 00:31:41,580
呃，是把外联家给转化成了一个内连接，然后这里的话是不一样的这里

506
00:31:41,910 --> 00:31:44,160
这里是把外联家整个给移掉

507
00:31:44,550 --> 00:31:46,530
然后他有两个条件需要满足

508
00:31:46,590 --> 00:31:47,880
第一个条件是

509
00:31:48,330 --> 00:31:49,110
我知道

510
00:31:49,320 --> 00:31:52,050
连接算子的上层算子

511
00:31:52,055 --> 00:31:54,900
就是包括她的父亲算是以及祖先算是

512
00:31:54,905 --> 00:31:59,250
她只需要我连接的这个凹槽表就是外表这个列

513
00:31:59,550 --> 00:32:00,600
其实第一个条件

514
00:32:00,630 --> 00:32:03,180
第二个需要同时满足的条件的话

515
00:32:03,185 --> 00:32:06,390
呃，分为两类，第一类是条件21就是

516
00:32:06,720 --> 00:32:12,030
她的婴儿表内表参与连接的列值，是具有唯一性属性的

517
00:32:12,450 --> 00:32:14,970
怎么去理解这个东西就是？

518
00:32:15,660 --> 00:32:16,530
如果

519
00:32:16,560 --> 00:32:17,730
像刚才说的

520
00:32:17,940 --> 00:32:18,750
我的

521
00:32:19,170 --> 00:32:24,480
奥特尔奥特之王的一个执行逻辑是，如果我外表在内表能够

522
00:32:24,485 --> 00:32:29,790
找到匹配的话，我输出我的外表，如果不能找到匹配的话，我也会输出

523
00:32:29,795 --> 00:32:31,590
外表只是说我

524
00:32:31,620 --> 00:32:35,550
把樱婴儿专的话补充了NASA的值，然后再输出出去

525
00:32:35,555 --> 00:32:37,920
所以从这样来看的话，总结起来就是

526
00:32:37,925 --> 00:32:41,970
外表的美一行一定会被输出至少一次

527
00:32:42,120 --> 00:32:43,890
然后他可能会被输出多次

528
00:32:44,280 --> 00:32:49,590
多次的情况就是我能够找到匹配，并且有多少匹配的时候，我就会被锁

529
00:32:49,595 --> 00:32:54,900
做多次，然后输出了一次的情况，就是我只能够找到一个匹配，或者是我

530
00:32:54,905 --> 00:32:56,190
我没有匹配的时候

531
00:32:56,940 --> 00:32:58,440
然后如果

532
00:32:58,890 --> 00:33:02,850
我的上层节点只需要OT表的数据

533
00:33:02,940 --> 00:33:05,550
并且内表的那个连接的

534
00:33:05,555 --> 00:33:10,860
面值只有具有唯性的话，这个情况下，我外表最多就只能

535
00:33:10,865 --> 00:33:13,410
能够在内边找到一个匹配

536
00:33:13,740 --> 00:33:16,410
那么，我外表最多就会被

537
00:33:17,160 --> 00:33:20,580
就是最多最多会被输出一次

538
00:33:20,910 --> 00:33:26,010
也就是说，结合刚才那个结论就是外表在这种情况下，他会

539
00:33:26,040 --> 00:33:28,710
且被其只会被输出一次

540
00:33:28,920 --> 00:33:32,640
那么我其实就整个只需要把外表

541
00:33:33,270 --> 00:33:34,620
往外出租就可以了

542
00:33:35,010 --> 00:33:36,210
以这个例子为例

543
00:33:36,750 --> 00:33:37,680
体育表

544
00:33:37,800 --> 00:33:43,110
左连左外连接t2标，然后连接的条件是七点诶，等于t

545
00:33:43,115 --> 00:33:43,890
第二天

546
00:33:43,950 --> 00:33:47,340
这个他是一个有带有有那个属性的这么一个链

547
00:33:47,345 --> 00:33:51,030
我对于我们一行的第一，这个数据的话

548
00:33:51,330 --> 00:33:56,190
我要么能够在第二找到一个匹配，要么我一个匹配都找不到

549
00:33:56,340 --> 00:34:01,650
如果我能够找到一个匹配，我就只会输出踢的这一行数据输出去，如果我不能

550
00:34:01,655 --> 00:34:06,960
能够找到这个匹配，我也会把当前踢输出一次，并且是补的那样，所以

551
00:34:07,260 --> 00:34:08,340
不管我

552
00:34:08,370 --> 00:34:13,080
能不能够找到匹配我踢这一行都会被输出一次出去？

553
00:34:13,380 --> 00:34:18,690
而且我的上层节点又只需要提交列，这个时候我就可以整个把这个查询

554
00:34:18,840 --> 00:34:22,080
改写成一个t表上的一个群聊，嫂子可以哦

555
00:34:23,850 --> 00:34:24,600
然后

556
00:34:27,150 --> 00:34:29,760
满足就是外联皆消除

557
00:34:29,765 --> 00:34:35,070
我刚才说有满需要满足了两条两个条件，第一个条件就是只需要外表练练，第二个条件

558
00:34:35,075 --> 00:34:40,380
两类，第二类就是上层，算是他只需要外表去重之后

559
00:34:40,385 --> 00:34:45,690
这这其实逻辑和刚才那个是一样的，因为我外表可能会被输出

560
00:34:45,870 --> 00:34:51,180
输出一次或者多次，如果我上层算是有一个去重的逻辑，那么我以

561
00:34:51,210 --> 00:34:54,570
也就是意味着我上层只需要说返回

562
00:34:54,900 --> 00:34:56,850
就是左边的外表的

563
00:34:56,880 --> 00:34:59,070
一次就可以了，那么我也可以把

564
00:34:59,130 --> 00:35:01,980
把整个那个外连接从这个逻辑

565
00:35:01,985 --> 00:35:04,320
我自己执行计划里头给去除掉

566
00:35:05,280 --> 00:35:06,570
你说这个例子就是

567
00:35:06,660 --> 00:35:09,000
听一听还是一个左外连接，然后

568
00:35:09,120 --> 00:35:14,430
七年间，条件是提点币等于贴二点b，这个也就没有满足条件21了，所以就不能

569
00:35:14,435 --> 00:35:16,860
能够用21，加上调节一种方式

570
00:35:16,890 --> 00:35:18,330
然后这个时候我可以判断

571
00:35:18,630 --> 00:35:23,940
因为我上层首先只用到了t一点哎，也就是t外表的外表的练

572
00:35:24,180 --> 00:35:27,390
第二次他带了一个，第四个，她会去从

573
00:35:27,690 --> 00:35:31,230
这个时候的话，我们可以把整个查询给改写成

574
00:35:31,260 --> 00:35:33,840
T表上面做一次驱虫再度聚合再给

575
00:35:37,470 --> 00:35:41,190
然后第四个例子是啊，连接顺序的一个调整

576
00:35:41,400 --> 00:35:46,710
所谓的连接顺序，就是当我们的查询比较复杂，涉及到有

577
00:35:46,715 --> 00:35:52,020
很多个表之间的连接操作的时候，我需要对这些连接的一个顺序做出来

578
00:35:52,025 --> 00:35:53,160
是一个调整

579
00:35:53,165 --> 00:35:55,560
来让我的执行计划是一个

580
00:35:55,565 --> 00:35:57,060
比较高效的执行计划

581
00:35:57,690 --> 00:35:59,220
他的一个方式就是

582
00:35:59,550 --> 00:36:04,770
第一步，我提取出参与连接的输入算式，也就是相当于

583
00:36:04,775 --> 00:36:05,490
我

584
00:36:05,520 --> 00:36:09,240
参与连接的每个基本表，把它拿出来

585
00:36:09,480 --> 00:36:14,790
第二个是对这些对不对？这些算子我去计算它的统计信息

586
00:36:15,240 --> 00:36:16,860
包括他的址方图

587
00:36:16,865 --> 00:36:21,630
以及他的数据的一个美每一列上面的，比如说adv值是多少？

588
00:36:21,900 --> 00:36:27,210
然后第三步如果是我判断当前的那个参与连接的表的书

589
00:36:27,215 --> 00:36:29,550
数量如果表的数量比较小的话

590
00:36:29,555 --> 00:36:34,860
我们用动态规划，动态规划的方法去求解一个最优的一个连接顺序，如果

591
00:36:34,865 --> 00:36:40,170
比较多数量比较多的，我会用一个贪心的算法去纠结，求解，一个次优的一个人就是

592
00:36:40,620 --> 00:36:45,930
因为如果数量的参与，连接的表的数量比较多的话，再用中那个话可能

593
00:36:45,960 --> 00:36:48,060
时时间在开销上会比较大

594
00:36:50,400 --> 00:36:51,630
一个例子就是

595
00:36:52,260 --> 00:36:57,570
假如我有三张表，TT TT 3来做那个连接，然后每张表的一个

596
00:36:57,575 --> 00:37:00,870
行数大概是十行100行100行

597
00:37:04,380 --> 00:37:09,420
然后首先贪心算法的话，他的一个方式就是

598
00:37:09,425 --> 00:37:12,990
我从这张这三张表里头去选择出一个

599
00:37:13,380 --> 00:37:15,900
横竖最小那张表作为我

600
00:37:15,905 --> 00:37:18,900
呃，参与连接的最开始的目标

601
00:37:19,260 --> 00:37:23,040
从从这里来看的话，就是踢一张表，然后她会去

602
00:37:23,700 --> 00:37:29,010
去和赫尔尝试做一次连接，发现连接完之后我估算出来当前

603
00:37:29,040 --> 00:37:34,350
连接会产生的行数是800行，然后我在用t1和t3做一次连接

604
00:37:35,070 --> 00:37:38,670
然后发现产生了一个结果，即是200行

605
00:37:38,730 --> 00:37:44,040
这个情况下，我们会选择提鲜和梯上去做连接，然后再和t2去做连接

606
00:37:45,870 --> 00:37:49,380
这是大概的一个呃，贪心算法的一个

607
00:37:49,440 --> 00:37:50,460
啊？

608
00:37:50,670 --> 00:37:52,530
一个逻辑的一个

609
00:37:52,710 --> 00:37:58,020
一个理解，然后动态规划的话，其实就是也是一个自底向上的

610
00:37:58,025 --> 00:37:58,950
那一个

611
00:37:59,010 --> 00:37:59,790
方式

612
00:38:00,720 --> 00:38:04,770
比如说我是三张表做连接的话，我会先对每一张表

613
00:38:04,800 --> 00:38:05,550
就是

614
00:38:05,670 --> 00:38:10,980
第一表第二表，第三表我分别去求解它的最后的一个方式，然后就是相当于第一

615
00:38:10,985 --> 00:38:11,580
一层

616
00:38:11,730 --> 00:38:17,040
第二场，我会去计算，但我两张表参与参与军队的两那个表的个

617
00:38:17,045 --> 00:38:22,350
就是二的时候，这个时候我的一些最优的方案是什么？就比如说，我可以算出来te

618
00:38:22,355 --> 00:38:27,060
T2然后t1和t3t2和t3然后我再选择一个最优的作为

619
00:38:27,240 --> 00:38:28,320
对于那个

620
00:38:28,350 --> 00:38:30,480
呃，作用的表的连接数

621
00:38:30,540 --> 00:38:35,850
为二的时候的一个左右键，然后我在在网上再就是作为第二层第三层

622
00:38:35,855 --> 00:38:36,720
这就是

623
00:38:37,260 --> 00:38:42,570
我的连接表的数量为三的时候三他有几种做法有

624
00:38:42,810 --> 00:38:48,120
它只有两种，一种组合方式就是1+2的组合方式，那么我可以从第一层里头

625
00:38:48,360 --> 00:38:49,440
选择出

626
00:38:49,445 --> 00:38:54,750
那个参与表的连接，为数量为一的时候，那个方案，然后与第二

627
00:38:54,755 --> 00:38:59,160
二层的参与表的连接数量为二的结果作为一个

628
00:38:59,490 --> 00:39:02,700
组合，然后算出来一个结果，然后

629
00:39:03,120 --> 00:39:06,120
在往上走，如果参与的表达数量为四的话呢就是

630
00:39:06,180 --> 00:39:07,200
1+3

631
00:39:07,260 --> 00:39:12,570
然后或者是2+2，然后他再来做比较，也就是说它是一个置顶

632
00:39:12,780 --> 00:39:15,990
自底向上的一个穷举，并且是

633
00:39:16,020 --> 00:39:19,080
有记录中间结果的这么一个过程

634
00:39:23,010 --> 00:39:28,320
前面介绍的就是大概的逻辑化的部分，需要需要知道

635
00:39:28,325 --> 00:39:33,330
要的一些内容，然后用了四个例子来介绍详细介绍一下四条规则

636
00:39:33,450 --> 00:39:38,760
然后下载现在我们就是进入到物理优化这个部分，物流的话，为什么会需要物理由？

637
00:39:38,765 --> 00:39:39,360
话

638
00:39:39,720 --> 00:39:44,580
就是有有一些规则的话，他并不一定是最优的

639
00:39:44,610 --> 00:39:49,920
他可能是有一些选择，就会模棱两可，他就具有这种属性，为什么会模棱两可？因为

640
00:39:50,190 --> 00:39:55,500
它需要由具体的表的数据来决定哪些选择才是最好的

641
00:39:55,680 --> 00:40:00,990
第一个，第二个是他，可能你不同的选择的话，是需要依赖于你的

642
00:40:00,995 --> 00:40:06,300
机器的物理配置呢，你在不同的机器的物理配置上面的话，她也会有

643
00:40:06,360 --> 00:40:08,820
不同的选择是更优的这么一个

644
00:40:09,240 --> 00:40:10,890
啊，这么一个规律

645
00:40:10,980 --> 00:40:12,540
就好比说

646
00:40:13,050 --> 00:40:15,360
他需要你的话，他可能在

647
00:40:15,390 --> 00:40:20,160
内存比较大的情况下，这种机器的话，它是一个比较好比较

648
00:40:20,250 --> 00:40:22,920
比较合适，一种选择，如果你机器的

649
00:40:22,950 --> 00:40:28,050
那个内存配置会非常小的话，这个时候我可能选择，因为这种是这种事种比较好的方式

650
00:40:29,130 --> 00:40:33,780
然后也和你的整个的集群的一个复杂有关系

651
00:40:34,140 --> 00:40:35,940
所以它就会导致

652
00:40:36,300 --> 00:40:41,610
有一些逻辑的一些优化的话，他并不一定会更好，也所以就需要

653
00:40:41,615 --> 00:40:43,260
根据具体的

654
00:40:43,350 --> 00:40:48,660
你的一个是物理数据，一个是你的当前的一些配置来决定我是

655
00:40:48,665 --> 00:40:50,370
是否应用这种优化？

656
00:40:54,450 --> 00:40:58,920
然后我们看一下物流化需要做的一些大概的事情就是

657
00:40:59,430 --> 00:41:01,620
以这个查询为例，他是

658
00:41:01,625 --> 00:41:06,930
两张表做昨晚t ET 2，然后就问你条件是在ce上面坐坐啊，然后

659
00:41:06,935 --> 00:41:11,970
最后是有一个作文，结果做按照ce做一个排序，那么

660
00:41:12,570 --> 00:41:17,880
我在排序，首先对于排序这个这个羽翼我有两种实现法

661
00:41:17,885 --> 00:41:18,630
方式

662
00:41:18,660 --> 00:41:23,970
第一种是我引入硕士这个节点这个关系代数的节点去实现

663
00:41:23,975 --> 00:41:24,930
排序

664
00:41:24,990 --> 00:41:30,300
第二个是我依赖于下层节点来提供这个顺序，下层决定可能会

665
00:41:30,330 --> 00:41:35,640
比如说我通过索引就能够提供这个顺序，那我就不需要到这种叫做排序，所以它也引入

666
00:41:35,645 --> 00:41:38,610
一个叫罗密欧搜索这么一个阶段，然后

667
00:41:39,120 --> 00:41:42,510
所以你这里有两个选择，一种是用

668
00:41:42,990 --> 00:41:48,300
硕士来实现这个排序，另一种就是用，因为此来实现这个排序，然后再往下走的话

669
00:41:48,480 --> 00:41:50,520
因为这个里头会有一个疑问

670
00:41:50,580 --> 00:41:55,890
希望也有三种不同的实现方式，一种是用哈西用另外一种是用背的，一种还有一种

671
00:41:55,895 --> 00:41:57,420
使用因为此六靠不住

672
00:41:57,510 --> 00:42:02,820
第二层，我也有三种选择，然后第三层再往下走，每一个表象的话，我也有不同的

673
00:42:02,825 --> 00:42:03,810
选择方式

674
00:42:03,870 --> 00:42:09,180
第一个是我可能选择表嫂全表扫描，第二个是我可能选择有所以

675
00:42:09,240 --> 00:42:14,550
如果如果有所以，那么可以选择是所以或者是我有多个索引的时候，我需要选择其中的

676
00:42:14,555 --> 00:42:17,280
一个所以来提供我的这个房方式

677
00:42:17,580 --> 00:42:22,890
所以它就有不同的组合方式，然后产生出最终的执行计划，也不同的组合

678
00:42:23,130 --> 00:42:28,440
然后物理优化就需要说，在这些组合的方式中去，根据你当前的表情

679
00:42:28,445 --> 00:42:33,750
数据具体情况以及你的机器的一些具体情况来选择出最合适的一个

680
00:42:33,755 --> 00:42:34,650
执行计划

681
00:42:37,020 --> 00:42:42,330
然后物理优化需要做的决策，就包括第一选择，所以还是全标上

682
00:42:42,335 --> 00:42:44,040
就是最底层的那个决策

683
00:42:44,100 --> 00:42:49,410
第二，如果选择索引的话，需要选择哪一个？所以呢，来作为他的访问方式

684
00:42:49,620 --> 00:42:54,930
然后再往上走就是逻辑算子他的物理实现上面是有不同的实现方式的

685
00:42:55,320 --> 00:43:00,630
包括第一连一个聚合算子聚合算子，现在也有哈哈西聚合算

686
00:43:00,900 --> 00:43:02,550
可能流逝的聚合算子

687
00:43:03,060 --> 00:43:08,370
第二是连接，算是连接，算是刚才也说有三种连接算子，然后第三是排序的算法排序

688
00:43:08,375 --> 00:43:13,680
的话可以提供依赖于下层，算是提供的一个顺序，也可以你自己去做一个排序，然后

689
00:43:13,685 --> 00:43:18,570
第四个物流化，需要做的角色是是否是否能够将蒜子下推

690
00:43:18,930 --> 00:43:24,240
这个地方的下降和刚才逻辑优化的部分讲到的下垂就不一样，刚才逻辑的话讲的

691
00:43:24,245 --> 00:43:28,350
下推是在整个计算成功的吓退这里的下垂是指将

692
00:43:28,500 --> 00:43:31,080
算是从计算成绩推到存储层

693
00:43:32,040 --> 00:43:37,350
因为我们在开KTV端，实现了一个模块叫作QQ CC CC能够把她他

694
00:43:37,355 --> 00:43:42,660
能够负责去执行一些从她继续往下推到他可以等的一些计算，如何？

695
00:43:42,665 --> 00:43:43,350
我记

696
00:43:43,440 --> 00:43:44,460
就是好比

697
00:43:44,580 --> 00:43:49,890
低密层这个逻辑，我可以把低密测算至从当前的太低密节点下推到

698
00:43:50,190 --> 00:43:55,500
再给我点点，在每个节点上面先限制一下返回的条数，然后再再再点

699
00:43:55,505 --> 00:43:57,990
站在太极病程，再做一个最终的一个

700
00:43:58,200 --> 00:44:00,960
一个理解成这样的话会减少

701
00:44:01,080 --> 00:44:01,800
从

702
00:44:02,040 --> 00:44:06,090
群组成道道道道计算成了一个网络开销

703
00:44:06,750 --> 00:44:10,530
然后目前我们实现的，嗯，考虑下推的

704
00:44:10,680 --> 00:44:15,990
对对，这三个算是实现了一个考虑是否将其下载到存储层第一个是

705
00:44:15,995 --> 00:44:19,200
聚合算式，第二个是丽丽丽丽，第三个是托普恩

706
00:44:22,260 --> 00:44:25,560
然后他物流化具体是怎么实现的呢？

707
00:44:25,620 --> 00:44:30,930
在介绍它的实现方式之前，先介绍一个概念，就是一个算子上面的

708
00:44:30,935 --> 00:44:36,240
一个物理属性，每一个算式都有每一个物理算子都有一个物理属性，这个物理属性

709
00:44:36,245 --> 00:44:38,970
不包括主要的内容包括三点

710
00:44:39,360 --> 00:44:44,670
第一点是我当前算是在计算机执行，还是在存储上执行，也就是说

711
00:44:44,675 --> 00:44:47,190
我校推到了，他就是开会曾去执行

712
00:44:47,195 --> 00:44:52,500
第二个节点，第二个属性是我当前算子的输出是否按照

713
00:44:52,505 --> 00:44:57,210
到了某某一列或者是某几列是有序的，这个我会记录下来

714
00:44:58,020 --> 00:44:59,790
第三个物理属性是

715
00:44:59,850 --> 00:45:00,510
过

716
00:45:00,570 --> 00:45:05,880
整个蒜子预期预期输出多少行，整个查询就会结束了

717
00:45:06,270 --> 00:45:07,680
这个就是说为了

718
00:45:07,740 --> 00:45:13,050
这一点主要是未来为了用来处理，当我的查询中包含厘米

719
00:45:13,055 --> 00:45:15,480
成这种语句的时候，如果

720
00:45:15,690 --> 00:45:21,000
不考虑这一点的话，我可能就是不同的，不同的选择，或者是不同的算法

721
00:45:21,005 --> 00:45:22,830
实现的话，他在

722
00:45:23,100 --> 00:45:24,630
启动就是

723
00:45:25,170 --> 00:45:30,480
他在那个就是我们后来会我们后面会介绍就说她是他是以代价的方式来选择

724
00:45:30,720 --> 00:45:31,530
那个

725
00:45:31,860 --> 00:45:36,720
哪一种方式是更好的，然后选择代价最低的一个方式，然后

726
00:45:37,260 --> 00:45:42,570
我们在计算这个算子实现的那个代价的时候会有一个类似于叫

727
00:45:43,620 --> 00:45:47,310
就是不同的算子的话，它的总代价可能是一样的

728
00:45:47,315 --> 00:45:52,620
但是呢，它启动代价的可能是不一样的，什么是启动代价就是我返回从从从

729
00:45:52,625 --> 00:45:56,340
我的算子开始执行到返回第一行的时候

730
00:45:56,460 --> 00:46:01,770
他的这个代价是多少？以及我返回完所有的行的时候，它的代价是多少钱？

731
00:46:01,775 --> 00:46:07,080
前者指的就是一个启动代价，后者指的就是他的一个总代价，如果我不区分这个东西

732
00:46:07,085 --> 00:46:07,860
不是的话

733
00:46:08,520 --> 00:46:13,830
假如说我的查询里面带了一个厘米尺一的话，我的总代价可能是一样的，那么他们可能

734
00:46:13,835 --> 00:46:14,520
一个

735
00:46:14,670 --> 00:46:19,980
平等的一个选择，但是我有一些有一些选择他的企业代价会更高

736
00:46:20,190 --> 00:46:25,500
有一些选择他的企业力量会很低，那么对于启动大家很低的这一类选择的话

737
00:46:25,650 --> 00:46:27,480
那么，它可以更快地去

738
00:46:27,510 --> 00:46:32,820
返回我所需要的那一行数据，所以它对于整个查询来说的话

739
00:46:32,825 --> 00:46:38,130
那种启动，代价更低的，那他可能才是一个更好的选择，所以我们需要在这个地记录运行

740
00:46:38,135 --> 00:46:40,500
其输出多少行，整个查询就会结束

741
00:46:43,560 --> 00:46:45,900
然后整个搜索的一个框架就是

742
00:46:46,170 --> 00:46:51,480
根据当它的输入，就是刚才那个逻辑化阶段的那个生存的那个啊！

743
00:46:51,485 --> 00:46:53,880
曾经计划的一个数，然后

744
00:46:53,970 --> 00:46:59,280
呃，这个数的话就包含了很多的逻辑算子每一个节点就是一个关系代数的一个逻辑算

745
00:46:59,285 --> 00:47:04,590
及我需要的一个物理属性，然后我把这个逻辑算是给映射成e

746
00:47:04,595 --> 00:47:08,010
一个物理算是这是整个搜索框架需要做的一个事情

747
00:47:08,250 --> 00:47:11,370
然后这个是整个整个搜索的一个

748
00:47:11,375 --> 00:47:16,680
方方式是一个自定向下搜索的一个过程，并且会记录

749
00:47:16,685 --> 00:47:21,990
中间的一些搜索结果，如果我后续节点在搜索的过程中发现诶我

750
00:47:21,995 --> 00:47:25,680
直接点这个这种属性加上这个算子

751
00:47:25,685 --> 00:47:30,990
他的映射已经被搜索过了，我可以直接用这个中间中间基本上要来这个结果

752
00:47:31,620 --> 00:47:32,940
然后

753
00:47:33,090 --> 00:47:35,850
怎么去衡量这个嗯？

754
00:47:35,855 --> 00:47:39,840
啊，先说一下，就是这个需要的这个物理属性是怎么确定的吧？

755
00:47:40,560 --> 00:47:42,690
从从顶向下搜索的时候

756
00:47:42,695 --> 00:47:45,690
在更接近的时候，这个物理属性视为空

757
00:47:45,900 --> 00:47:46,740
然后

758
00:47:46,770 --> 00:47:51,150
如果我在实现的过程中的话，比如说我当时算只是一个

759
00:47:52,440 --> 00:47:54,030
那个聚合算子

760
00:47:54,360 --> 00:47:59,670
聚合算子我可以去罗列出来，我有哪几种实现方式，像刚才说的种种事

761
00:47:59,675 --> 00:48:03,240
哈西聚合的分子，另外一种是留是聚合的算子

762
00:48:03,360 --> 00:48:08,670
游戏就和他算算是他就有一个要求就是我的子节点的输出必须是

763
00:48:08,675 --> 00:48:13,980
按照按照估计，那一列是有序的，那么我在流式聚合的时候，我就

764
00:48:13,985 --> 00:48:15,030
直接读

765
00:48:15,090 --> 00:48:20,310
那个，我的输入的那个数据读到那一列的值不一样的时候我就认为

766
00:48:20,340 --> 00:48:25,650
和刚才的分组是属于不同的分组了然后我就可以更新一些中间状态

767
00:48:25,655 --> 00:48:30,810
对流式聚合，他需要我的下层的输入，是一个按规定有序

768
00:48:30,815 --> 00:48:31,470
那么

769
00:48:31,770 --> 00:48:33,480
这个时候我就需要说

770
00:48:34,470 --> 00:48:35,670
我在实现

771
00:48:35,675 --> 00:48:40,740
这个流式聚合的这个物理算子的时候，我就会对我的子节点要求

772
00:48:40,980 --> 00:48:42,270
说我需要

773
00:48:42,420 --> 00:48:47,730
按照这一列有序，然后把相当于是我的流量聚合这个算子去射

774
00:48:47,735 --> 00:48:53,040
我给我的子节点需要的这个物理属性，然后当我在美剧我的

775
00:48:53,045 --> 00:48:58,350
子节点的这个物理实现的时候，我就会发现我上层节点需要我按照这一列

776
00:48:58,355 --> 00:49:03,030
去有序输出，所以我在考考虑我自身的时间方式的时候

777
00:49:03,390 --> 00:49:08,130
我觉得有一些就不能不行了，像这波斯坦克，可能就不行了，我就只能够用

778
00:49:08,940 --> 00:49:10,170
然后

779
00:49:10,440 --> 00:49:15,750
整个搜索如果成功的话，可能会有就是不同的就是不同的组合嘛，因为我们

780
00:49:15,755 --> 00:49:18,660
一种节点会生成不同的

781
00:49:18,750 --> 00:49:24,060
物理实现方式，然后它的子节点又会生成不同的物理实现方式，然后我把这些事物里说

782
00:49:24,065 --> 00:49:29,370
这些方式给组合起来的时候，我怎么去衡量每一个物理执行计划是更好的？

783
00:49:29,640 --> 00:49:32,340
就像刚才说的，我们用的是一个代价的模型

784
00:49:32,640 --> 00:49:37,800
我们计算每一个节点，他的一个代价，这个代价的话

785
00:49:37,860 --> 00:49:40,470
大概会包括比如说CPU的一个代价

786
00:49:40,475 --> 00:49:41,280
然后

787
00:49:41,340 --> 00:49:42,540
还有哪个代价？

788
00:49:42,570 --> 00:49:47,880
网络的一个代价，以及跟内存的代价，把这些代价给整合起来

789
00:49:47,885 --> 00:49:53,190
加起来的话，作为整个执行计划的一个总代价，然后从这些不同的因为不同的

790
00:49:53,195 --> 00:49:57,750
组合产生的不同的一个执行计划，然后冲出去执行计划的那个这个这个

791
00:49:57,780 --> 00:50:03,090
即合理的选择出一个代价最低的作为我们最优的一个执行计划，然后怎么去？

792
00:50:04,320 --> 00:50:09,390
估算这个代价估算代价的话，就需要说有两个东西，第一个就是

793
00:50:10,110 --> 00:50:15,420
一个cos么的，我就是代价模型代价模型就是指的是相当于我说的CPU

794
00:50:15,425 --> 00:50:20,730
内存网络和还有她可能每一每一项每一个维度，它是有一个基准

795
00:50:20,735 --> 00:50:22,050
一个单位值

796
00:50:22,110 --> 00:50:24,690
然后比如说我处理一行

797
00:50:24,930 --> 00:50:30,240
银行数据，我的CP的开销是多少，然后我扫描多少数据，它的IO的开销

798
00:50:30,245 --> 00:50:34,770
多少这些是有一些基础的单位在这个地方？然后另外我们

799
00:50:34,775 --> 00:50:37,830
就是计算代价的另外一个输入就是函数

800
00:50:37,860 --> 00:50:43,170
涉及到的当前算子的一个行数是多少？我用这个函数和刚才的那些基准的

801
00:50:43,175 --> 00:50:48,480
这就可以计算出处理这些所有行需要的一个总代价，然后把每个算式的加起来作为她

802
00:50:48,750 --> 00:50:54,030
整个整体计划的那个代价，所以这里就涉及到我要去估算这个函数是多少？

803
00:50:54,360 --> 00:50:56,100
函数的估算是由

804
00:50:56,105 --> 00:51:01,410
当前执行计划节点的一些条件，或者是他的她的内容

805
00:51:01,415 --> 00:51:02,460
一个非要的

806
00:51:02,580 --> 00:51:07,890
结合我的统计信息来计算出我当前

807
00:51:07,895 --> 00:51:13,200
算算子可能返回多少行，然后我的是它的返回的行数，其实就是为上层

808
00:51:13,205 --> 00:51:14,670
也剪了一个输入的函数

809
00:51:14,910 --> 00:51:16,740
比如说

810
00:51:17,940 --> 00:51:20,130
一个例子就是谁来个车

811
00:51:20,220 --> 00:51:25,530
一个趔反正可以把这张表，然后威尔条件是a列大于一亿

812
00:51:25,740 --> 00:51:28,620
那么我就可以把a大于一这个条件

813
00:51:28,830 --> 00:51:34,140
然后结合我的统计信息，统计心里面就包括了有直方图以及

814
00:51:34,145 --> 00:51:39,450
给我的一个CMS盖茨就是基本的是一个等值等值条件的一个品质

815
00:51:39,690 --> 00:51:45,000
然后结合这两个东西的话，我和和和那个去计算出满足

816
00:51:45,005 --> 00:51:50,310
大于满足a，大于一这个条件的行数是多少，然后并且把这份

817
00:51:50,315 --> 00:51:55,620
统计信息更新出来的统计信息给维护到我当前的算子中，然后一步一步往上传

818
00:51:55,800 --> 00:52:01,110
每一个节点的话，都会维护自己的一份统计信息，然后这样网上传销

819
00:52:01,115 --> 00:52:03,510
下去的话，相当于每个节点也可以算出

820
00:52:03,900 --> 00:52:08,790
自己节点需要处理的那个行数是多少，以及输出的行数是多少？

821
00:52:10,620 --> 00:52:15,930
然后这一步的话，他会考虑算是是否会提前结束，也就是会用到这里面

822
00:52:15,935 --> 00:52:18,180
描述的这个物理属性第三点中

823
00:52:18,210 --> 00:52:19,020
那个

824
00:52:19,110 --> 00:52:20,850
啊，那个值

825
00:52:20,880 --> 00:52:23,490
比如说你可能是一个，忒不是干

826
00:52:23,850 --> 00:52:29,160
对于推博士干这一个算子的话，我在再计算我本身的代价的时候，我就会去考

827
00:52:29,165 --> 00:52:34,080
率如果我上层是有一个厘米尺一的话，那我只需要扫一行数据

828
00:52:34,320 --> 00:52:39,630
我就可以整个直播是按这个算子就可以结束了，那么我本身的代价就是一行

829
00:52:39,635 --> 00:52:42,180
数据乘以一个艾欧的一个

830
00:52:42,420 --> 00:52:47,730
一个基准代价，而不是说我整张表的所有的数据都需要扫完之后我才

831
00:52:47,735 --> 00:52:50,850
去去去，结束而来，作为他的一个代价

832
00:52:54,060 --> 00:52:58,290
然后以你举个例子来描述一下物理优化的一个

833
00:52:58,560 --> 00:53:03,870
逻辑第一个例子就是，所以你选择，所以说你说就是有

834
00:53:03,875 --> 00:53:07,950
这里就涉及到一个非常重要的一个模块就是叫文静

835
00:53:08,340 --> 00:53:12,780
人家这个模块就是输入式，我有我有一张表

836
00:53:12,785 --> 00:53:16,170
然后以及有一堆这张表上面的一些条件

837
00:53:16,440 --> 00:53:18,270
然后我需要把我输出是

838
00:53:19,290 --> 00:53:24,600
我美我对对于这张表上的每一个所以我有哪哪些条件呢？

839
00:53:24,605 --> 00:53:29,100
都用到索引的访问上面去以及构造出来那个

840
00:53:30,270 --> 00:53:35,580
把这些条件放在那个索引上面之后都做出来那个位置，这个位置的话，会下船到那个

841
00:53:35,640 --> 00:53:38,340
泰克威曾直接去做那个扫描了

842
00:53:39,330 --> 00:53:44,640
所以，尊敬的话，第一个就是给给定的索引，去抽取一个的访问条件

843
00:53:44,645 --> 00:53:46,800
自己不的话，他就会去考虑

844
00:53:47,100 --> 00:53:48,660
这个条件

845
00:53:48,690 --> 00:53:51,690
条件的话会非常复杂，可能会是以

846
00:53:51,750 --> 00:53:55,680
CF或者是DNF的形式存在的就

847
00:53:55,890 --> 00:53:57,300
看这个例子里头就是

848
00:53:57,540 --> 00:54:02,850
T MA=1 a gt AB=2 AD tec=3，这就是一个以cm乘以

849
00:54:02,855 --> 00:54:05,670
形式，然后如果我的

850
00:54:06,240 --> 00:54:07,920
体表上面有

851
00:54:08,280 --> 00:54:13,590
有索引是比如说在a上面有一个索引的话，对于这个条件，我就可以直接把

852
00:54:13,650 --> 00:54:18,960
七点1=1给抽取出来作为这个诶，这个索引上面的一个访问条件

853
00:54:19,440 --> 00:54:20,580
然后

854
00:54:20,585 --> 00:54:25,890
还有一些更复杂的，就是像DNF这种形式的话嗯，如果是

855
00:54:26,820 --> 00:54:30,660
还有就是CF d和DNF组合，这种嵌套的方式

856
00:54:30,780 --> 00:54:32,520
呃，他这里的一个

857
00:54:33,180 --> 00:54:34,560
原则就是说

858
00:54:35,010 --> 00:54:39,570
我们在抽取这个访问方式的时候不能产生

859
00:54:39,600 --> 00:54:43,560
服务那个铁粉的那种误判，所谓的服务员就是

860
00:54:44,490 --> 00:54:45,720
我判断说

861
00:54:45,725 --> 00:54:48,510
这一列满这一行，满满足条件

862
00:54:48,515 --> 00:54:53,820
如果我满足条件的话，我我对索引访问的话，我就会往上反回，如果我不满足条件的话

863
00:54:54,000 --> 00:54:54,660
我就

864
00:54:54,720 --> 00:55:00,030
这样就会保留，就不会往上返回了然后如果说我判断他是那个特殊的

865
00:55:00,240 --> 00:55:02,640
就是她他不满足那个

866
00:55:02,670 --> 00:55:06,030
哦，所以条件的话，那么他一定就不能够

867
00:55:06,035 --> 00:55:06,930
满足

868
00:55:06,960 --> 00:55:12,270
就是她不存在这个可能性，就是说他满足了其他的那个条件，导致满足这个条件是成立

869
00:55:12,630 --> 00:55:17,940
所以所以就是那个特别就是你判断说它是一个那个对不对？但是你出错了，所以就不

870
00:55:17,945 --> 00:55:23,250
也有这种情况，但是我们是允许有副作用的，贴不清清楚出现的，因为

871
00:55:23,850 --> 00:55:26,520
像这个条件啊！

872
00:55:28,020 --> 00:55:29,370
生这个条件的话就是

873
00:55:29,460 --> 00:55:34,770
如果我把提点a=1给抽取出来，作为AA这个索引上面的这个发方式的话

874
00:55:35,100 --> 00:55:38,460
这个时候如果我们有有一行满足的是

875
00:55:38,465 --> 00:55:43,770
AA=1，但是他呢币等于一个三，其实他整个条件他是不满足的

876
00:55:43,830 --> 00:55:49,140
但是在于我这个地方的话，它是一个抛的题目的一个判断，然后我把它返回回去了这种

877
00:55:49,145 --> 00:55:54,450
允许的，因为我在上层，我还会去判断一次起点币等于二，然后如果在

878
00:55:54,455 --> 00:55:58,860
在内存她她他不能满足条件的话，它也会被过滤掉，所以

879
00:55:59,220 --> 00:56:04,530
原则就是说，索引过滤不能够有佛寺那个帖子，但是我们可能会存在有佛斯抛的铁粉

880
00:56:04,535 --> 00:56:05,370
很清醒的

881
00:56:06,450 --> 00:56:10,410
还有就是索引可能会是一种符合索引的进行

882
00:56:10,620 --> 00:56:12,990
相当于说这里是考虑的事

883
00:56:12,995 --> 00:56:15,660
AA，列上面的，所以但有可能是

884
00:56:15,665 --> 00:56:18,870
我的所以是一个ABC3类的一个符合，所以

885
00:56:18,875 --> 00:56:24,180
在这种情况下，我七点ACC en tt abe=2按照t CC=4大于三

886
00:56:24,185 --> 00:56:27,390
整个条件都可以被作为ABC这个

887
00:56:27,450 --> 00:56:29,400
三列符合所以上面的一个

888
00:56:29,405 --> 00:56:34,710
访问方式的，因为他前两列都是一个等级条件，第三列是一个

889
00:56:34,715 --> 00:56:35,430
一个

890
00:56:35,490 --> 00:56:40,800
非常式条件，他这种情况下是可以的，但如果踢点b这里从等于二

891
00:56:40,805 --> 00:56:46,110
改成了一个大于二的话，这种情况下，我们就不能够把整个条件都做了

892
00:56:46,115 --> 00:56:51,420
ABC，这个索引上面的一个方法是，而只能够把前缀a=1

893
00:56:51,425 --> 00:56:56,220
一些的b大于二，这一部分条件，作为他的一个方程式

894
00:56:57,060 --> 00:56:59,190
然后这里捡到的一个东西就是

895
00:56:59,310 --> 00:57:04,620
呃，我们正在做的一个新的一个房方式叫做应该是的儿子为什么会需要有这个？

896
00:57:05,250 --> 00:57:10,560
就是以这个例子为例，提点a=1n tube=2，在这种情况下，因为

897
00:57:10,565 --> 00:57:15,870
我们要秉持这个原则，这个原则就是不能有符合那个题目，在这种情况下我们

898
00:57:15,875 --> 00:57:18,480
没有办法把任何一个条件

899
00:57:18,960 --> 00:57:24,270
任何一部分条件给下推到一个索引上面去，如果说我有一个诶上面的，所以

900
00:57:24,510 --> 00:57:29,820
我这个时候是不能够把tea=1给下垂下垂的下垂到那个所以上面去的

901
00:57:29,825 --> 00:57:32,880
所以，如果我下学期去的话，我返回出来的结果

902
00:57:32,970 --> 00:57:34,200
它可能

903
00:57:34,230 --> 00:57:39,540
七点a=1些他不满足，但是它是满足to b=2的

904
00:57:39,660 --> 00:57:44,970
然后我这部分我已经被过滤掉了，我就没有办法把这部分完整的，结果给返回回去了

905
00:57:45,240 --> 00:57:50,550
所以在这种情况下，目前我们没有办法选择，所以然后为了解决这种情况

906
00:57:50,555 --> 00:57:53,910
我们再引入一个应该十分二级这种方式

907
00:57:54,240 --> 00:57:59,550
应该是不是就是我之前所以你的访问其实都只只能够用一个？所以那我现在可能考虑

908
00:57:59,555 --> 00:58:04,860
多个所以我现在用两个所有人访问第一个，所以你就是a的，所以第二个所以势必得所

909
00:58:04,865 --> 00:58:10,170
A的索引方面做一个过滤提点a=1的所有的这些满足条件的我都拿出来

910
00:58:10,175 --> 00:58:15,480
在我在壁纸，所以身边再做一次过滤tab=20我所有的拿出来，然后把这两个

911
00:58:15,485 --> 00:58:18,870
结果的集合，做一次逻辑获得操作

912
00:58:18,960 --> 00:58:23,850
然后把最终的一个结果作为需要输出到上层节点的一个输出

913
00:58:24,540 --> 00:58:28,800
所以这些是应该各式面具的一个方式，这个是正在目前正在开发的一个

914
00:58:29,520 --> 00:58:32,610
然后另外就是润泽里面

915
00:58:32,615 --> 00:58:34,620
除除了刚才说到的吧！

916
00:58:34,625 --> 00:58:39,930
把那个访问条件给抽取出来之外，但还需要做的一个事情去做

917
00:58:39,935 --> 00:58:41,490
条件的一个化简

918
00:58:41,730 --> 00:58:43,170
比如说我抽取出来

919
00:58:43,175 --> 00:58:45,420
ATM a=1

920
00:58:45,450 --> 00:58:47,760
按的七点a=2

921
00:58:47,790 --> 00:58:51,750
这种情况下，我可以直接判断说这个条件永远不可能成立

922
00:58:52,260 --> 00:58:57,570
那么我就把整个条件给化简成一个复式，然后参与到后面再参与到后面的

923
00:58:57,575 --> 00:59:01,320
一些优化过程中，这样会简化整个的一个逻辑过程

924
00:59:06,030 --> 00:59:11,340
然后除了这个软件，这个模块的话，然后我们另外的一个需要嗯介绍

925
00:59:11,345 --> 00:59:16,650
笑的就是索引的一个剪裁算法叫做该来你铺里这个模块

926
00:59:17,520 --> 00:59:22,320
为什么需要这个东西就是其实如果统计信息？

927
00:59:22,325 --> 00:59:23,730
以及我们的

928
00:59:23,790 --> 00:59:26,460
就犹如抗战的一个菇，算是一个

929
00:59:26,640 --> 00:59:28,620
完备的一个方案的话

930
00:59:28,740 --> 00:59:34,050
就是或者是统计信息是一个准确的，准确的这种情况的话，我们是不需要用那个改概念

931
00:59:34,230 --> 00:59:39,540
因为我们刚才介绍的那一套套搜索框架以及COSMO的，这样算出来的话，我们是雨

932
00:59:39,545 --> 00:59:44,850
其中，能够选到索要索要所所需要的那个，所以呢，但是呢？

933
00:59:44,855 --> 00:59:49,920
运运行情况中，它可能会是会出现一些和预期中不一样的情况

934
00:59:49,925 --> 00:59:54,480
一个就是统计信息，可能并不是最新的，第二个是我的

935
00:59:54,485 --> 00:59:59,790
估算的时候可能因为我们估算有的时候会用一些假设，比如说独立性假设，或者是

936
00:59:59,795 --> 01:00:05,100
均匀分布假设那你真实的一个数据分布，她并不满足这两种假设，或者是说这个

937
01:00:05,105 --> 01:00:10,410
当中，假设有一些偏差的时候，那么我们的估算可能就有误差，然后有误差，再加上

938
01:00:10,415 --> 01:00:13,410
统计不准的话，就可能导致我们会选上

939
01:00:13,890 --> 01:00:19,200
不是那么最优的那种，只那个索引，然后这一步的话是尴尬

940
01:00:19,205 --> 01:00:21,330
初恋的话，他的目的就是

941
01:00:21,720 --> 01:00:23,280
去首先从

942
01:00:23,370 --> 01:00:27,000
规则上面去才剪掉去删除掉一些

943
01:00:27,450 --> 01:00:32,760
所以然后让我们在选择的时候，把这个范围缩小，减少我们

944
01:00:32,765 --> 01:00:34,380
出错的一个可能性

945
01:00:34,980 --> 01:00:37,560
他具体的一个实现方式就是

946
01:00:37,860 --> 01:00:43,170
它说它是它会从三个维度来评估每一个索引

947
01:00:43,230 --> 01:00:43,980
然后

948
01:00:44,100 --> 01:00:45,960
这三个维度，不包括第一

949
01:00:46,530 --> 01:00:51,840
每一个索引的访问完之后，是否还需要再回表所谓的回报就是因为我每一个

950
01:00:51,845 --> 01:00:55,380
所以里头他的气就是索引列的值

951
01:00:55,410 --> 01:01:00,720
16是一个我们叫做如外地或者是憨豆，其实就是一个每一行的一个标识符

952
01:01:00,960 --> 01:01:02,460
然后如果

953
01:01:03,030 --> 01:01:08,340
我的整个查询我所需要的那些练的话，我都在这个索引都能够找到的

954
01:01:08,490 --> 01:01:09,930
但我其实不需要回表

955
01:01:09,935 --> 01:01:12,270
但如果我这个索引包含的列

956
01:01:12,300 --> 01:01:17,610
并不能够完全覆盖我整个查询需要的那些练，但我需要回到根据我所以呢？

957
01:01:17,615 --> 01:01:22,920
拿到的那个标识符就回到那个表里头，把其他的例子指出来，然后再参与

958
01:01:23,130 --> 01:01:26,790
上层的一些计算，所以这就涉及到是否需要回表

959
01:01:27,090 --> 01:01:28,320
第二个维度是

960
01:01:28,710 --> 01:01:30,420
是否能够提供？

961
01:01:30,480 --> 01:01:35,490
我上层节点关心的一些有就是顺序上面的一些属性

962
01:01:35,495 --> 01:01:40,800
也就是刚才说到的物理属性呢？其中的三条中，其中一条，然后第三个

963
01:01:40,805 --> 01:01:41,730
条件就是

964
01:01:42,180 --> 01:01:43,440
我从

965
01:01:43,830 --> 01:01:49,140
啊，从那个过滤条件里面，从根据文件抽取出来，那些访问题

966
01:01:49,145 --> 01:01:49,920
好像说

967
01:01:50,190 --> 01:01:52,590
这些条件都涵盖了哪些列？

968
01:01:52,830 --> 01:01:57,240
从这三个维度来评估这个所以然后第二步就是

969
01:01:57,480 --> 01:02:02,430
评估完之后的话，我就会去比较，每个索引，并且删除掉一些索引

970
01:02:02,435 --> 01:02:05,040
什么情况下，我可以删除，所以就是

971
01:02:05,400 --> 01:02:10,710
假如说我有两个，所以x和YY x在这三个维度上它

972
01:02:10,980 --> 01:02:12,210
不比我差

973
01:02:12,330 --> 01:02:14,940
就第一个条件，同时第二个条件

974
01:02:14,970 --> 01:02:19,800
X，在至少一个维度上，它比我更好，在这种情况下

975
01:02:19,805 --> 01:02:22,140
X1定会比我更好

976
01:02:22,350 --> 01:02:23,070
就是

977
01:02:23,130 --> 01:02:28,440
从整整体来说的话，x1定会比YY更好，所以我们这种情况下，我们可以直接把外

978
01:02:28,445 --> 01:02:29,430
从

979
01:02:29,640 --> 01:02:33,180
候选集里头给剔除掉，避免我们

980
01:02:34,350 --> 01:02:39,660
后续可能因为统计性误差，或者是估算误差，而误选上歪这个，所以

981
01:02:41,310 --> 01:02:44,160
这个例子就是来阐述这个概念铺里的

982
01:02:45,090 --> 01:02:50,400
比如说这张表，睇睇上面的一个条件是a=1n，你的b大于二

983
01:02:50,640 --> 01:02:51,930
然后过着呗

984
01:02:52,080 --> 01:02:55,320
A然后我有两个，所以x YY

985
01:02:55,440 --> 01:03:00,060
所以的话，第一个x所以是在ABC上面的一个符合，所以

986
01:03:00,065 --> 01:03:05,370
第二个yI，所以是在a上面的一个所以然后我们从三个维度来衡量这个

987
01:03:05,375 --> 01:03:06,000
对了

988
01:03:07,140 --> 01:03:09,480
衡量这个这这这张表

989
01:03:09,485 --> 01:03:12,900
和衡量这两个，所以第一个是是否需要回表

990
01:03:13,110 --> 01:03:18,420
因为我这里是谁那个心，我这个这个t表的话，我会去判断啊，是不是只报？

991
01:03:18,425 --> 01:03:23,730
这AB两列，然后这个调这个这个例子的话，应该是ABC有三列就是t表，包括AB y

992
01:03:23,735 --> 01:03:29,040
一生有三年，所以对于x和y来说的话，因为因为我是谁来执行，所以我

993
01:03:29,045 --> 01:03:30,210
都需要回表

994
01:03:30,215 --> 01:03:35,160
他们俩是同等的，在这个维度上，第二是能否提供有价值的

995
01:03:35,220 --> 01:03:40,530
顺序输出输出输出顺序，在这个例子里面的话，因为我郭德拜a

996
01:03:40,860 --> 01:03:46,170
我可能是有两种实现方式，这个old by第一个就是用一个数字，第二个就是用一个

997
01:03:46,175 --> 01:03:49,260
索引本身提供了一个a的顺序，然后从

998
01:03:49,290 --> 01:03:54,600
从这种本身提供a顺序这一点上来说的话，x和y都能够满足这个条件

999
01:03:54,930 --> 01:04:00,240
所以他们在第二个维度上也是一个等价的，然后第三个维度访问条件中

1000
01:04:00,245 --> 01:04:05,550
涵盖的列如果我选择x所以的话，我a=1按照比大于二都可以

1001
01:04:05,555 --> 01:04:10,860
作为他的一个访问条件，如果我选择歪，所以的话，我就只能够用a=c座

1002
01:04:10,865 --> 01:04:16,170
他的一个访问条件，在这种情况下，我们可以看到h索引的访问条件中含

1003
01:04:16,175 --> 01:04:21,480
大的劣势歪索引中方面强就是涵盖的劣势，一个超级因为它包含

1004
01:04:21,485 --> 01:04:26,790
AB，两个烈而y值包含a这一个列在这种情况下，我就可以判断说

1005
01:04:26,850 --> 01:04:28,830
X1定比我更好

1006
01:04:29,760 --> 01:04:34,410
所以我们这种情况下就可以直接把歪，所以造成后面的这个给剔除掉

1007
01:04:38,790 --> 01:04:40,230
然后

1008
01:04:40,350 --> 01:04:45,660
就是在检查完了之后再做完概念处理之后的话，我们可能还还会剩下

1009
01:04:45,665 --> 01:04:48,600
有很多个所以然后这个时候我们需要去

1010
01:04:48,750 --> 01:04:51,510
从这些索引中去选择出其中一个

1011
01:04:51,660 --> 01:04:53,400
对于我们是比较好那个

1012
01:04:53,580 --> 01:04:58,890
然后这个时候就需要考虑我，所以是否能够满足父亲节点要求的一个

1013
01:04:58,895 --> 01:05:01,230
这属于个顺序的属性

1014
01:05:01,830 --> 01:05:02,880
这个例子就是

1015
01:05:02,940 --> 01:05:03,780
T表

1016
01:05:03,900 --> 01:05:09,210
然后调过滤条件是七点AW at tim be=27点c大于三，然后

1017
01:05:09,215 --> 01:05:10,530
好点儿的提点被

1018
01:05:10,620 --> 01:05:11,640
废水所以

1019
01:05:11,670 --> 01:05:16,980
A列所以及BC生命的符合索引附近阶段，这个时候可能要求的属性是？

1020
01:05:16,985 --> 01:05:22,290
数学题要么就是TVB，要么就是没有然后如果再考

1021
01:05:22,295 --> 01:05:24,120
考虑7-b的情况下的话

1022
01:05:24,300 --> 01:05:29,610
啊，我就只能够选BC这个符合，所以才能够满足我上层需要的那个

1023
01:05:29,640 --> 01:05:33,330
七点必着这个顺序的熟悉，这个时候a就不能被选择了

1024
01:05:36,090 --> 01:05:41,400
然后剔除掉一些之后的话也是选择代价最低的那个在剩余的那些，所以你才去

1025
01:05:41,405 --> 01:05:42,990
选择一个代价最低的

1026
01:05:43,410 --> 01:05:45,270
然后以这个例子为

1027
01:05:45,275 --> 01:05:50,580
来来阐述一下，就是还是刚才那个例子，a=1b=2c=3周瑜，他的过滤条件

1028
01:05:50,585 --> 01:05:52,170
然后厘米这个这个条件

1029
01:05:52,380 --> 01:05:57,690
然后备选也是诶，上面的索引和必胜客上面的符合，所以这个时候我可选的方案

1030
01:05:57,695 --> 01:05:58,830
就是

1031
01:05:59,190 --> 01:06:02,460
我可以在t表上面做一个全标上

1032
01:06:02,465 --> 01:06:07,770
前面扫扫完之后，我再把这三个条件作为一个过滤给加在上面，作为一个时代的节点做

1033
01:06:07,775 --> 01:06:08,610
架在上面

1034
01:06:08,615 --> 01:06:13,920
第一种方案，第二种方案是我应该可以干在a上面做一个

1035
01:06:13,925 --> 01:06:17,910
应该可以干，再加上BC两列上面的一个非要脱

1036
01:06:18,480 --> 01:06:23,790
第三个呢，我是在BC两页上面做一个应对各自，然后再把a等

1037
01:06:23,795 --> 01:06:26,940
手机作为那个肥肉馅放在上面，因为

1038
01:06:27,330 --> 01:06:29,310
这个时候就需要根据

1039
01:06:29,315 --> 01:06:33,360
每一每每每一个索引，上面我去估算它

1040
01:06:33,480 --> 01:06:38,790
大概满足条件的那个行数是多少？然后来计算它的代价来决定这三种

1041
01:06:38,795 --> 01:06:44,100
那哪一种是更好的，因为我们没有办法，现在没有办法说一定哪一种方案是更好的，因为

1042
01:06:44,820 --> 01:06:50,130
他波斯看来说他虽然说嫂子行数可能会多一些，但是他避免了回

1043
01:06:50,135 --> 01:06:55,440
必要这种情况，音这个是干的少的行数可能会少一些，但是它需要有一个大部分干就是

1044
01:06:55,445 --> 01:06:56,400
那个过程

1045
01:06:56,430 --> 01:06:57,030
然后

1046
01:06:57,420 --> 01:07:00,960
他大概在家可能并不会比他又不是干一定会低的

1047
01:07:00,965 --> 01:07:02,400
所以我们需要根据

1048
01:07:02,610 --> 01:07:07,920
A或者是BC这个直方图以及他的摄影师guy上面的统计信息

1049
01:07:07,925 --> 01:07:13,230
判断我能够满足当前下周相聚的条件的行数是多少，然后这些

1050
01:07:13,235 --> 01:07:18,540
磅数在乘以之前提到的那个基准的一些代价值，然后来估算出

1051
01:07:18,545 --> 01:07:22,170
一种可选方案的代价，选择代价最低的那个

1052
01:07:24,090 --> 01:07:29,400
这就是饿，所以选择以所以选择来描述了一下整个物理优化的大概的

1053
01:07:29,405 --> 01:07:30,450
这个过程

1054
01:07:32,130 --> 01:07:35,580
然后物流的话大概介绍完之后，我们就要回顾一下就是

1055
01:07:35,585 --> 01:07:40,890
这个这部分包括逻辑化和物理化的一个关键的知识点，关键知识点

1056
01:07:40,895 --> 01:07:41,700
也包括

1057
01:07:41,880 --> 01:07:44,940
第一次优化器，整个的一个流程是什么？

1058
01:07:45,000 --> 01:07:46,050
像刚才说的

1059
01:07:46,055 --> 01:07:47,730
第一部，他是一个预处理

1060
01:07:47,735 --> 01:07:51,780
去处理就包含我需要去判断是否能够用

1061
01:07:51,840 --> 01:07:54,240
那种特殊的关系，这种方式

1062
01:07:54,420 --> 01:07:55,140
如果

1063
01:07:55,230 --> 01:07:59,460
不能的话，那么我进入第二步就是去构造初始的一个

1064
01:07:59,520 --> 01:08:00,750
国际执行计划

1065
01:08:00,840 --> 01:08:06,150
在这一切的过程中，他是一个自底向上的过程，并且已经开始

1066
01:08:06,155 --> 01:08:07,800
参与了一些优化的

1067
01:08:07,830 --> 01:08:10,320
步骤进了然后

1068
01:08:10,350 --> 01:08:14,640
第三个就是根据构造出来的这个初始的逻辑执行计划

1069
01:08:14,700 --> 01:08:16,680
做一些等价的变形

1070
01:08:16,830 --> 01:08:19,860
也就是说，我应用逻辑化的规则

1071
01:08:19,980 --> 01:08:21,630
啊，然后去做变形

1072
01:08:22,080 --> 01:08:22,980
第四部

1073
01:08:22,985 --> 01:08:24,030
然后根据

1074
01:08:24,120 --> 01:08:26,880
呃，物理优化的那个圆里去

1075
01:08:27,120 --> 01:08:32,430
判断去去去把那些模棱两可的不一定会更好的，那些优化来决定

1076
01:08:32,490 --> 01:08:35,730
我是否用哪种方案去去去实现它

1077
01:08:36,180 --> 01:08:38,670
然后他的一个大概原理就是

1078
01:08:38,675 --> 01:08:40,230
是一个基于

1079
01:08:41,670 --> 01:08:42,390
就是

1080
01:08:42,510 --> 01:08:47,820
其实整个优化器的话，它是一个基于规则的优化，以及基于代价的一个

1081
01:08:47,825 --> 01:08:49,050
就画了一个组合

1082
01:08:50,250 --> 01:08:55,560
这是第一个知识点，第二个就是优化器各阶段的原理，以及背后的逻辑就是刚才介绍的

1083
01:08:55,565 --> 01:08:59,610
就是为什么她她他做了些什么事情，他为什么会这么做？

1084
01:09:02,400 --> 01:09:06,030
他们回顾一下，就是之前说到的那个学习目标

1085
01:09:06,390 --> 01:09:10,230
第一个就是了解一句话去需要解决的问题，他需要在

1086
01:09:10,440 --> 01:09:15,750
和合理的时间内去找到一个合理的执行计划，然后对执行计划有一个感性的认识

1087
01:09:15,990 --> 01:09:21,300
它就是一颗啊，一颗树树里面的话，每一个节点都是一个关系代数的

1088
01:09:21,480 --> 01:09:22,200
算子

1089
01:09:22,800 --> 01:09:28,110
然后优化区域处理阶段，需要去做喷嚏盖检查以及去构造出

1090
01:09:28,115 --> 01:09:33,420
实际经济化以及做一些初始的一些优化，然后常用的逻辑化规则

1091
01:09:33,425 --> 01:09:36,630
或谓词下推啊外连接消除

1092
01:09:36,690 --> 01:09:38,700
然后万年接转内连接

1093
01:09:38,760 --> 01:09:40,350
以及聚合的下推

1094
01:09:40,470 --> 01:09:45,780
还有一些比如说列警察这些，然后理解又物理化学原理，物理，物理学原理就是

1095
01:09:46,350 --> 01:09:51,660
是一个自顶向下的一个过程，搜索过程，然后是一个g

1096
01:09:51,665 --> 01:09:52,920
批发的搜索

1097
01:09:54,900 --> 01:10:00,210
然后第三部分我们就进入到了就是执行计划缓存这个功能的那个介绍

1098
01:10:00,540 --> 01:10:04,830
然后首先也是讲一下这部分的一个学习目标

1099
01:10:04,860 --> 01:10:06,570
然后介绍学习的内容

1100
01:10:06,630 --> 01:10:11,580
内容的话，包括执行计划缓存这个功能使用的场景是什么？

1101
01:10:11,585 --> 01:10:14,460
以及执行计划缓存，它实现了一个软件

1102
01:10:15,720 --> 01:10:17,010
学习目标部分

1103
01:10:17,760 --> 01:10:21,930
第一次了解什么是资金计划缓存以及其实使用场景

1104
01:10:22,020 --> 01:10:27,060
第二个是了解经济要缓存的实现方式，第三是理解其计划缓存的一些行为

1105
01:10:29,490 --> 01:10:30,600
适用场景

1106
01:10:30,930 --> 01:10:33,480
我们目前使用场景是指针对

1107
01:10:33,540 --> 01:10:37,950
索赔rxk QQ这种执行模式才做了那个执行计划缓存

1108
01:10:37,955 --> 01:10:43,260
像普通的直接执行一个十来克的这种查询的话，他是不会用执行就要缓存的

1109
01:10:43,380 --> 01:10:45,690
然后相关的有一些

1110
01:10:45,870 --> 01:10:49,530
配置参数和以及它的默认值，这也要介绍一下

1111
01:10:49,590 --> 01:10:51,990
主要是有四个，第一个就是

1112
01:10:52,380 --> 01:10:57,690
是控制是否打开这个普菲尔普兰克斯，然后默认值设为

1113
01:10:57,870 --> 01:11:03,180
作死，也就是说默认是没有打开的，如果你想用这个功能的话，你需要去配置文件里面把

1114
01:11:03,185 --> 01:11:04,200
设置为TRUE

1115
01:11:04,710 --> 01:11:05,430
然后

1116
01:11:06,090 --> 01:11:11,400
第二个是她的一个从开始的整个一个容量是多少？它是100这个等下我会介绍

1117
01:11:11,405 --> 01:11:12,420
它是怎么用的？

1118
01:11:12,990 --> 01:11:17,940
而第三个值是一个嗯内存的一个临界值

1119
01:11:18,060 --> 01:11:23,370
一个比例，这个比例没认知是01，然后第四个是一个叫做纷纷

1120
01:11:23,375 --> 01:11:24,900
是麦克妹妹一直

1121
01:11:24,905 --> 01:11:27,240
这个值是00后

1122
01:11:27,360 --> 01:11:28,590
这个值的话

1123
01:11:29,370 --> 01:11:32,910
后面介绍一下这三个职务的，后面再介介绍一下

1124
01:11:34,590 --> 01:11:37,830
然后先说这个执行计划缓存的一个实现细节

1125
01:11:37,835 --> 01:11:41,160
它其实本质上就是一个lru的一个目标

1126
01:11:41,730 --> 01:11:44,730
而我在执行匹配的时候

1127
01:11:44,820 --> 01:11:46,080
我只会去

1128
01:11:46,085 --> 01:11:48,690
就用那个拍摄的接口把

1129
01:11:49,260 --> 01:11:54,570
把那个CT语句给解析成那个抽象语法树，然后给存下来，然后并不会

1130
01:11:54,575 --> 01:11:57,840
去做真正的那个啊优化欠的部分的

1131
01:11:57,845 --> 01:11:58,740
那个开销

1132
01:11:59,040 --> 01:11:59,790
然后

1133
01:12:00,540 --> 01:12:05,850
第二个，第二就是我们在陪陪完了之后去做那个x QQ q调用一次

1134
01:12:05,855 --> 01:12:09,660
QQ的时候，这个时候我才会去把之前

1135
01:12:09,990 --> 01:12:14,040
你存下来的那个车车轮法术拿出来去做

1136
01:12:14,190 --> 01:12:19,500
流化器就是把把它放到液化气里头去，生成真正的物理执行计划，然后把

1137
01:12:19,505 --> 01:12:21,330
这个执行计划呢我

1138
01:12:21,930 --> 01:12:25,530
这个时候去把它放入到那个l iu那张列表里头

1139
01:12:26,220 --> 01:12:31,530
然后续的那个x QQ的话，我直接从缓存池里头拿就行，就是说那个l

1140
01:12:31,535 --> 01:12:36,480
还有那个列表里头去拿，我之前第一次x QQ存下那个执行计划

1141
01:12:36,600 --> 01:12:41,910
然后并且呢，拿出来之后，我需要去调整相应的一些值那些产量

1142
01:12:42,540 --> 01:12:47,850
比如说你一开始你也可以QQ的时候你可能用的是一个参数是一个是VI

1143
01:12:48,360 --> 01:12:53,670
A大于一然后应用的参数是一然后他生成的一个执行计划，是那个闰九月

1144
01:12:53,820 --> 01:12:55,080
从一到正无穷

1145
01:12:55,260 --> 01:13:00,570
那么我在第二次的时候那个参数可能是变成a大于二，这时候我从那个执行计划拿出

1146
01:13:00,575 --> 01:13:05,640
需要把那个位置调整一下，从以前的一道政府中变成一个现在的二道政府上

1147
01:13:06,150 --> 01:13:08,910
这是这是需要调整的一部分，然后

1148
01:13:09,360 --> 01:13:13,680
什么时候会触发这个l iu的一个淘汰就是淘汰条件

1149
01:13:14,250 --> 01:13:16,110
第一个就是当我

1150
01:13:16,260 --> 01:13:18,660
往那个l21里面放的时候

1151
01:13:18,665 --> 01:13:20,820
放那个执行计划的时候，发现它的

1152
01:13:21,090 --> 01:13:23,730
当前，这张这这条料表上面的那个

1153
01:13:23,850 --> 01:13:29,160
个数已经超过了之前那个配置表里的配置，向你的那个可拍摄体验

1154
01:13:29,165 --> 01:13:30,810
这个值不值的100吗？

1155
01:13:30,815 --> 01:13:34,200
超过数量超过100的时候，那么这个时候就会去

1156
01:13:34,740 --> 01:13:40,050
淘汰掉一个112又可以并，并且把那个空间给释放出来，然后我把我当成自己给加进

1157
01:13:40,380 --> 01:13:41,640
另外一个条件是

1158
01:13:41,670 --> 01:13:45,480
当前，他就被进程，它的内存使用超过了一个预支

1159
01:13:45,510 --> 01:13:49,110
这个阈值怎么计算呢？就是用刚才配置项列出来那几项

1160
01:13:49,410 --> 01:13:54,720
迹象的那个职来做了一个数学上面的一个计算，第一个就是

1161
01:13:55,260 --> 01:14:00,570
他把那个麦克斯妹妹围成了一个一减去那个为首像刚才那个为首

1162
01:14:00,575 --> 01:14:05,880
默认值是01，那么这里的话就是这个人比例的话就是09然后这个值默认

1163
01:14:05,885 --> 01:14:07,200
射程是零

1164
01:14:07,205 --> 01:14:08,220
您的时候

1165
01:14:08,580 --> 01:14:10,740
他设置那个参数的时候，他会去

1166
01:14:10,770 --> 01:14:11,550
啊？

1167
01:14:11,555 --> 01:14:16,860
如果我发发现你这个值是零的话，他就会拿当前机器上所有可用的内存

1168
01:14:16,865 --> 01:14:22,170
这个字，也就是说，当你整个泰迪，毕竟城使用的内存超过了当

1169
01:14:22,175 --> 01:14:27,480
目前机器可用内存的90%的时候，我也会去触发这个AR u的淘汰

1170
01:14:28,170 --> 01:14:30,180
淘汰掉一些之后，把我自己给加进去

1171
01:14:30,690 --> 01:14:34,260
所以这是大概的一个实现的一个细节

1172
01:14:38,970 --> 01:14:39,570
我想知道

1173
01:14:44,280 --> 01:14:45,630
然后

1174
01:14:46,410 --> 01:14:48,540
大概这部分也是

1175
01:14:48,600 --> 01:14:49,950
就是介绍这么多

1176
01:14:50,430 --> 01:14:55,740
这里的话有留了几个问题，可能大家感兴趣可以思考一下就是

1177
01:14:57,210 --> 01:15:01,470
对于整个刚才讲到的三部分内容的一些一些问题，第一个就是

1178
01:15:01,590 --> 01:15:05,850
我在构造好初始的那个逻辑，执行计划之后

1179
01:15:05,910 --> 01:15:07,350
我如何确定？

1180
01:15:07,590 --> 01:15:12,480
我在逻辑化阶段，需要应用哪些逻辑和规则？这是一个问题

1181
01:15:12,900 --> 01:15:14,220
第二个问题就是

1182
01:15:14,310 --> 01:15:18,750
在逻辑的阶段，因为我们刚才介绍的一个规则的调整

1183
01:15:18,810 --> 01:15:24,120
连接的顺序也就是装一个或者一条一条柜子，那么在这个位置的我是如何去？

1184
01:15:24,125 --> 01:15:26,250
处理笛卡尔集这种情形

1185
01:15:26,370 --> 01:15:30,330
也就是我两张表之间他没有具体的一个连接条件

1186
01:15:30,335 --> 01:15:31,920
他是一个笛卡尔积

1187
01:15:32,250 --> 01:15:34,710
正提醒在捐赠给我的时候是怎么处理的？

1188
01:15:35,130 --> 01:15:36,930
第三个问题是

1189
01:15:37,020 --> 01:15:42,330
有的时候优化器呢，他并不能够选择出我们想要的一些

1190
01:15:42,390 --> 01:15:43,770
这个执行计划

1191
01:15:43,860 --> 01:15:46,920
这个时候，我们提供那种方式就是优化气恨恨

1192
01:15:47,100 --> 01:15:50,250
也就是我在CF里头去嵌套一些

1193
01:15:50,310 --> 01:15:55,620
就是去去去加入一些类似于看门狗一样东西那种评论一样东西，然后

1194
01:15:55,625 --> 01:16:00,930
我去指定说让优化去选择，比如说你问的时候，我选择就问了算

1195
01:16:00,935 --> 01:16:06,240
法师释，他希望或者是因这个专业，我可以加这种东西，加这个配置这个

1196
01:16:06,245 --> 01:16:11,550
政策是如何生效，能在整个优化优化器的这个流程中，他是在哪一部？

1197
01:16:11,555 --> 01:16:13,830
过去生效的这个大家可以思考一下

1198
01:16:16,470 --> 01:16:18,450
然后就是答疑的一个安排

1199
01:16:18,540 --> 01:16:22,530
大家可以扫描这个二维码，然后上面去看一下吧

1200
01:16:24,210 --> 01:16:26,730
啊，今天大概介绍的一个内容就是这么多

1201
01:16:27,120 --> 01:16:28,290
我们今天就

1202
01:16:28,295 --> 01:16:29,430
在这里结束吧！

1203
01:16:34,140 --> 01:16:34,740
我不知道

